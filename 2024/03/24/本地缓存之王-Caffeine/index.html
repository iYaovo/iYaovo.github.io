<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>我的技术与生活——本地缓存之王-Caffeine | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <link rel="shortcut icon" href="/imgs/shortcut-icon.ico" type="image/x-icon">
  <link rel="stylesheet" href="/css/public.css" />
  <link rel="stylesheet" href="/css/layout.css" />
  <link rel="stylesheet" href="/css/iconfont.css" />
  <link rel="stylesheet" href="/css/APlayer.min.css" />
  <script src="/js/APlayer.min.js"></script>
  <script src="/js/jquery.min.js"></script>
  <script src="/js/jquery.pjax.min.js"></script>

  <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
  <script>
    document.title = `我的技术与生活——本地缓存之王-Caffeine`
  </script>
<meta name="generator" content="Hexo 6.3.0"></head>

<style>
  .load {
    width: 100%;
    height: 100vh;
    background-color: rgb(37, 35, 40);
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    position: relative;
    z-index: 9999;
  }
  .load-circle {
    width: 80px;
    height: 80px;
    border: 8px solid orange;
    border-bottom-color: transparent;
    border-radius: 50%;
    display: flex;
    justify-content: center;
    align-items: center;
    animation: rotate 1s linear infinite;
    filter: drop-shadow(0 0 3px orange);
  }
  .load-circle-inner {
    width: 40px;
    height: 40px;
    border: 8px solid orange;
    border-top-color: transparent;
    border-radius: 50%;
    animation: rotate-reverse .5s linear infinite;
  }
  .load-text {
    margin-top: 20px;
    font-size: 24px;
    color: orange;
    display: flex;
  }
  .load-text span {
    margin: 0 5px;
    text-shadow: 5px 5px 5px orange;
    animation: move 1s linear infinite;
  }
  .load-text span:nth-child(1) {
    animation-delay: -0.6s;
  }
  .load-text span:nth-child(2) {
    animation-delay: -0.5s;
  }
  .load-text span:nth-child(3) {
    animation-delay: -0.4s;
  }
  .load-text span:nth-child(4) {
    animation-delay: -0.3s;
  }
  .load-text span:nth-child(5) {
    animation-delay: -0.2s;
  }
  .load-text span:nth-child(6) {
    animation-delay: -0.1s;
  }
  @keyframes rotate {
    0% { transform: rotate(0); }
    100% { transform: rotate(360deg); }
  }
  @keyframes rotate-reverse {
    0% { transform: rotate(0); }
    100% { transform: rotate(-360deg); }
  }
  @keyframes move {
    0% { transform: translateY(0%) rotate(0) scale(1); }
    20% { transform: translateY(20%) rotate(10deg) scale(1.2); }
    80% { transform: translateY(-10%) rotate(-20deg) scale(.8);}
    100% { transform: translateY(0) rotate(0) scale(1); }
  }

  .progress {
    position: fixed;
    left: 0; top: 0;
    width: 0;
    height: 3px;
    background-color: green;
    transition: all cubic-bezier(0.215, 0.610, 0.355, 1) .1s;
    z-index: 9999;
  }

  .to-up {
    animation: toUp .5s 1;
  }
  .gray {
    position: fixed;
    left: 0;
    top: 0;
    width: 100%;
    height: 100vh;
    z-index: 9999;
    display: none;
    pointer-events: none;
    background-color: #000;
    mix-blend-mode: color;
  }
  @keyframes toUp {
    from { transform: translateY(15px); opacity: 0; }
    to { transform: translateY(0) ; opacity: 1; }
  }
</style>
<body>
  <div id="load" class="load">
    <div class="load-circle">
      <div class="load-circle-inner"></div>
    </div>
    <p class="load-text">
      <span>L</span>
      <span>O</span>
      <span>A</span>
      <span>D</span>
      <span>I</span>
      <span>N</span>
      <span>G</span>
    </p>
  </div>
  <div id="container" class="container w-100 vh-100" style="display: none;">
    <header class="header">
  <div class="header-wrapper">
    <div class="header-left">
      <div class="header-search">
        <input id="search-input" type="text" class="header-search--input" placeholder="请输入要检索的文章标题" />
        <span id="search-btn" class="header-search--icon"><i class="iconfont icon-sousuo"></i></span>
      </div>
      <div id="search-layer" class="header-search--layer hidden">
        <p class="title">
          <span>以下是搜索内容：</span>
          <span id="close-layer-btn">关闭</span>
        </p>
        <ul>
        </ul>
      </div>
    </div>
    <div class="header-right">
      <ul class="header-menu">
        <li>
          <a href="http://example.com/">
            <i class="header-menu--icon iconfont icon-shouye"></i>
            <span class="header-menu--span">首页</span>
          </a>
        </li>
        <li>
          <a href="http://example.com/log">
            <i class="header-menu--icon iconfont icon-rizhi"></i>
            <span class="header-menu--span">日志</span>
          </a>
        </li>
        <li>
          <a href="http://example.com/link">
            <i class="header-menu--icon iconfont icon-youqinglianjie"></i>
            <span class="header-menu--span">友情链接</span>
          </a>
        </li>
        <li>
          <a href="http://example.com/about">
            <i class="header-menu--icon iconfont icon-guanyuwomen"></i>
            <span class="header-menu--span">关于我</span>
          </a>
        </li>
      </ul>
    </div>
  </div>
</header>

<script>
  const ipt = document.querySelector('#search-input')
  const btn = document.querySelector('#search-btn')
  const layer = document.querySelector('#search-layer')
  const posts = JSON.parse(`[{"title":"对象转换工具","path":"2023/10/31/Mapstruct对象转换工具/"},{"title":"图片上传","path":"2023/09/01/图片上传-1/"},{"title":"代码随想录","path":"2023/10/17/代码随想录-2/"},{"title":"计算机网络","path":"2023/11/08/计算机网络-1/"},{"title":"MyBatis Plus","path":"2024/02/16/MyBatis-Plus/"},{"title":"ControllerAdvice","cover":null,"path":"2024/05/10/ControllerAdvice/"},{"title":"MinIO对象存储","path":"2024/05/11/MinIO对象存储/"},{"title":"Redis","path":"2024/02/29/Redis/"},{"title":"SpringSecurity","path":"2024/02/17/SpringSecurity/"},{"title":"本地缓存之王-Caffeine","path":"2024/03/24/本地缓存之王-Caffeine/"},{"title":"Web实时消息推送详解","path":"2024/03/11/Web实时消息推送详解/"}]`)
  ipt.addEventListener('keyup', e => {
    if (e.key === 'Enter') {
      handleSearch()
    }
  })
  btn.addEventListener('click', () => {
    handleSearch()
  })

  document.querySelector('#close-layer-btn').addEventListener('click', () => {
    layer.classList.toggle('hidden')
  })

  function handleSearch() {
    if (ipt.value.trim() === '') {
      return
    }
    let html = ''
    const targetPosts = posts.filter(post => post.title.includes(ipt.value))
    targetPosts.forEach(post => {
      html += `
        <li>
          <div>
            <a href="/${post.path}">${post.title.replace(new RegExp(ipt.value), `<span>${ipt.value}</span>`)}</a>
          </div>
          <img src="${post.cover || '/imgs/default-cover.webp' }" />
        </li>
      `
    })
    if (html.trim () === '') {
      html += '<p class="empty">没有搜索到内容</p>'
    }
    layer.querySelector('ul').innerHTML = html
    layer.classList.remove('hidden')
  }
</script> 
    <section id="main" class="main">
      <div class="main-left-wrapper">
<div class="main-left">
  <div class="main-left--block">
    <div class="main-left--info">
      <img src="/imgs/avatar.jpg"" class="main-left--avatar" />
      <div class="main-left--intro">
        <p class="main-left--name">iYaovo</p>
        <div class="main-left--tags">
          <span class="main-left--tag">中二</span>
          <span class="main-left--tag">宅</span>
        </div>
      </div>
    </div>
  
    <div>
      <div class="main-left--motto">
        <p>“时间不站在你那边”</p>
        <p></p>
      </div>
      <div class="main-left--github">
        <span class="line"></span>
        <a target="_blank" rel="noopener" href="https://github.com/iYaovo"><i class="logo iconfont icon-github-fill"></i></a>
        <span class="line"></span>
      </div>
      <div class="main-left--statics">
        <a href="/categories">
          <div>
            <span>4</span>
            <span>分类</span>
          </div>
        </a>
        <a href="/tags">
          <div>
            <span>0</span>
            <span>标签</span>
          </div>
        </a>
        <a href="/archives">
          <div>
            <span>6 </span>
            <span>归档</span>
          </div>
        </a>
      </div>
    </div>
  </div>

  <div class="main-left--block">
    <ul class="main-left--menu">
      
        <li>
          <a href="/">
            <span class="header-menu--span">小站首页</span>
            <i class="header-menu--icon iconfont icon-shouye"></i>
          </a>
        </li>
      
        <li>
          <a href="/log">
            <span class="header-menu--span">个人日志</span>
            <i class="header-menu--icon iconfont icon-rizhi"></i>
          </a>
        </li>
      
        <li>
          <a href="/link">
            <span class="header-menu--span">友情链接</span>
            <i class="header-menu--icon iconfont icon-youqinglianjie"></i>
          </a>
        </li>
      
        <li>
          <a href="/about">
            <span class="header-menu--span">关于自己</span>
            <i class="header-menu--icon iconfont icon-guanyuwomen"></i>
          </a>
        </li>
      
        <li>
          <a href="/tools">
            <span class="header-menu--span">我的工具</span>
            <i class="header-menu--icon iconfont icon-gongju"></i>
          </a>
        </li>
      
    </ul>
  </div>

  <div class="main-left--block">
    <div class="main-left--site">
      <h5 class="main-left--title">
        <span>站点信息</span>
        <i class="iconfont icon-zhandian"></i>
      </h5>
      <p class="main-left--subtitle">
        <span>文章数目：</span>
        <span>11 篇</span>
      </p>
      <p class="main-left--subtitle">
        <span>最近动态：</span>
        <span>今天</span>
      </p>
      <p class="main-left--subtitle">
        <span>上线时间：</span>
        <span>268天</span>
      </p>
      <p class="main-left--subtitle">
        <span>当前版本：</span>
        <span>v1.0.2</span>
      </p>
    </div>
  </div>
</div></div>
      <div id="main-container" class="main-container">


  <link rel="stylesheet" href="/css/partial/article.css" />

<div class="article-container">
  <div class="article">
    <h1 class="article-title">本地缓存之王-Caffeine</h1>
    <div class="article-info">
      <div class="article-info--item">
        <div class="article-info--info">
          
          <div class="article-info--categories">
            <span>分类：</span>
            <a class="category-link" href="/categories/%E5%90%8E%E7%AB%AF/">后端</a>
          </div>
          
          
          <div class="article-info--tags">
            <span>标签：</span>
            
          </div>
          
          <p class="article-info--date">日期：2024-03-24 14:10:40</p>
        </div>
        <img src="/imgs/default-cover.webp" alt="" class="article-cover">
      </div>
    </div>
    <article class="article-content markdown-body">
      <p>Caffeine的主要功能如图所示。支持手动&#x2F;自动、同步&#x2F;异步多种缓存加载方式，支持基于容量、时间及引用的驱逐策略，支持移除监听器，支持缓存命中率、加载平均耗时等统计指标。</p>
<p><img src="http://iyaovo.oss-cn-beijing.aliyuncs.com/myblog/Caffeine/caffine%E5%8A%9F%E8%83%BD.png"></p>
<h2 id="数据加载"><a href="#数据加载" class="headerlink" title="数据加载"></a>数据加载</h2><p>Caffeine提供以下四种类型的加载策略：</p>
<h4 id="1-Manual手动"><a href="#1-Manual手动" class="headerlink" title="1. Manual手动"></a>1. Manual手动</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">demo</span><span class="params">()</span>&#123;  </span><br><span class="line">    <span class="comment">// 创建一个新的Caffeine缓存构建器，并设置缓存过期策略和最大大小  </span></span><br><span class="line">    Cache&lt;String,String&gt; cache = Caffeine.newBuilder()  </span><br><span class="line">        .expireAfterWrite(<span class="number">20</span>, TimeUnit.SECONDS) <span class="comment">// 设置写入后20秒过期  </span></span><br><span class="line">        .maximumSize(<span class="number">5000</span>) <span class="comment">// 设置缓存的最大条目数为5000  </span></span><br><span class="line">        .build(); <span class="comment">// 构建缓存实例  </span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 1. 插入或更新一个条目  </span></span><br><span class="line">    cache.put(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;world&quot;</span>); <span class="comment">// 将键为&quot;hello&quot;的条目值设置为&quot;world&quot;  </span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 2. 查找一个条目，如果没找到则返回null  </span></span><br><span class="line">    <span class="type">String</span> <span class="variable">val1</span> <span class="operator">=</span> cache.getIfPresent(<span class="string">&quot;hello&quot;</span>); <span class="comment">// 尝试获取键为&quot;hello&quot;的条目值，如果找到则返回其值，否则返回null  </span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 3. 如果条目缺失，则查找并计算一个条目，如果无法计算则返回null  </span></span><br><span class="line">    cache.get(<span class="string">&quot;msg&quot;</span>, k -&gt; createExpensiveGraph(k)); <span class="comment">// 尝试获取键为&quot;msg&quot;的条目，如果没找到则使用lambda表达式计算并插入新值  </span></span><br><span class="line">    <span class="comment">// 注意：这里的lambda表达式 `k -&gt; createExpensiveGraph(k)` 是一个函数式接口的实现，它定义了如何计算新值  </span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 4. 移除一个条目  </span></span><br><span class="line">    cache.invalidate(<span class="string">&quot;hello&quot;</span>); <span class="comment">// 从缓存中移除键为&quot;hello&quot;的条目  </span></span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 这是一个私有静态方法，用于模拟一个耗时的操作（例如查询数据库）  </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">createExpensiveGraph</span><span class="params">(String key)</span>&#123;  </span><br><span class="line">    System.out.println(<span class="string">&quot;begin to query db...&quot;</span>+Thread.currentThread().getName()); <span class="comment">// 输出开始查询数据库的提示信息以及当前线程名  </span></span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">        Thread.sleep(<span class="number">2000</span>); <span class="comment">// 模拟耗时操作，让当前线程休眠2秒  </span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </span><br><span class="line">        <span class="comment">// 如果线程被中断，则捕获该异常，这里并没有做特殊处理  </span></span><br><span class="line">    &#125;  </span><br><span class="line">    System.out.println(<span class="string">&quot;success to query db...&quot;</span>); <span class="comment">// 输出查询数据库成功的提示信息  </span></span><br><span class="line">    <span class="keyword">return</span> UUID.randomUUID().toString(); <span class="comment">// 返回一个随机生成的UUID字符串作为查询结果  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2-Loading自动"><a href="#2-Loading自动" class="headerlink" title="2. Loading自动"></a>2. Loading自动</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">demo</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="comment">// 创建一个LoadingCache实例，配置了写入后5秒过期和最大容量为500  </span></span><br><span class="line">    LoadingCache&lt;String, String&gt; cache = Caffeine.newBuilder()  </span><br><span class="line">        .expireAfterWrite(<span class="number">5</span>, TimeUnit.SECONDS)  </span><br><span class="line">        .maximumSize(<span class="number">500</span>)  </span><br><span class="line">        .build(<span class="keyword">new</span> <span class="title class_">CacheLoader</span>&lt;String, String&gt;() &#123;  </span><br><span class="line">            <span class="comment">// 当缓存中不存在某个键时，调用此方法加载值  </span></span><br><span class="line">            <span class="meta">@Override</span>  </span><br><span class="line">            <span class="keyword">public</span> String <span class="title function_">load</span><span class="params">(String key)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">                <span class="keyword">return</span> createExpensiveGraph(key);  </span><br><span class="line">            &#125;  </span><br><span class="line">  </span><br><span class="line">            <span class="comment">// 当缓存中不存在多个键时，调用此方法批量加载值  </span></span><br><span class="line">            <span class="meta">@Override</span>  </span><br><span class="line">            <span class="keyword">public</span> Map&lt;String, String&gt; <span class="title function_">loadAll</span><span class="params">(Iterable&lt;? extends String&gt; keys)</span> &#123;  </span><br><span class="line">                System.out.println(<span class="string">&quot;build keys&quot;</span>);  </span><br><span class="line">                Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();  </span><br><span class="line">                <span class="keyword">for</span> (String k : keys) &#123;  </span><br><span class="line">                    map.put(k, k + <span class="string">&quot;-val&quot;</span>);  </span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="keyword">return</span> map;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;);  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 获取键为&quot;hello&quot;的值，如果缓存中不存在，则调用CacheLoader的load方法加载  </span></span><br><span class="line">    <span class="type">String</span> <span class="variable">val1</span> <span class="operator">=</span> cache.get(<span class="string">&quot;hello&quot;</span>);  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 批量获取键为&quot;key1&quot;和&quot;key2&quot;的值，如果缓存中不存在，则调用CacheLoader的loadAll方法加载  </span></span><br><span class="line">    Map&lt;String, String&gt; values = cache.getAll(Lists.newArrayList(<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;key2&quot;</span>));  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 模拟一个耗时的操作（例如查询数据库），并返回一个UUID字符串  </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">createExpensiveGraph</span><span class="params">(String key)</span>&#123;  </span><br><span class="line">    System.out.println(<span class="string">&quot;begin to query db...&quot;</span> + Thread.currentThread().getName());  </span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">        Thread.sleep(<span class="number">2000</span>); <span class="comment">// 模拟耗时操作  </span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </span><br><span class="line">        <span class="comment">// 异常处理  </span></span><br><span class="line">    &#125;  </span><br><span class="line">    System.out.println(<span class="string">&quot;success to query db...&quot;</span>);  </span><br><span class="line">    <span class="keyword">return</span> UUID.randomUUID().toString();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="3-Asynchronous-Manual异步手动"><a href="#3-Asynchronous-Manual异步手动" class="headerlink" title="3. Asynchronous Manual异步手动"></a>3. Asynchronous Manual异步手动</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">demo</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;  </span><br><span class="line">    <span class="comment">// 创建一个AsyncCache实例，配置了最大容量为500和写入后10秒过期  </span></span><br><span class="line">    AsyncCache&lt;String, String&gt; cache = Caffeine.newBuilder()  </span><br><span class="line">        .maximumSize(<span class="number">500</span>)  </span><br><span class="line">        .expireAfterWrite(<span class="number">10</span>, TimeUnit.SECONDS)  </span><br><span class="line">        .buildAsync();  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 尝试获取键为&quot;hello&quot;的值，如果缓存中不存在，则异步计算它  </span></span><br><span class="line">    <span class="comment">// 这里使用了Lambda表达式来定义如何计算缺失的键  </span></span><br><span class="line">    CompletableFuture&lt;String&gt; future = cache.get(<span class="string">&quot;hello&quot;</span>, k -&gt; createExpensiveGraph(k));  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 阻塞等待异步操作完成，并获取结果  </span></span><br><span class="line">    <span class="comment">// 注意：在实际应用中，通常不会直接调用future.get()，因为它会阻塞当前线程  </span></span><br><span class="line">    <span class="comment">// 更好的做法是使用CompletableFuture的回调机制（如thenApply, thenAccept等）来处理结果  </span></span><br><span class="line">    System.out.println(future.get());  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 模拟一个耗时的操作（例如查询数据库），并返回一个UUID字符串  </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">createExpensiveGraph</span><span class="params">(String key)</span> &#123;  </span><br><span class="line">    System.out.println(<span class="string">&quot;begin to query db...&quot;</span> + Thread.currentThread().getName());  </span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">        Thread.sleep(<span class="number">2000</span>); <span class="comment">// 模拟耗时操作  </span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </span><br><span class="line">        <span class="comment">// 异常处理  </span></span><br><span class="line">    &#125;  </span><br><span class="line">    System.out.println(<span class="string">&quot;success to query db...&quot;</span>);  </span><br><span class="line">    <span class="keyword">return</span> UUID.randomUUID().toString();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>AsyncCache</code>异步地获取或计算缓存条目。<code>AsyncCache</code>提供了异步操作的能力，这允许你在获取或计算缓存值时不会阻塞调用线程。这对于需要高并发和响应性的应用非常有用。</p>
<h4 id="4-Asynchronously-Loading异步自动"><a href="#4-Asynchronously-Loading异步自动" class="headerlink" title="4. Asynchronously Loading异步自动"></a>4. Asynchronously Loading异步自动</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">demo</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;  </span><br><span class="line">    <span class="comment">// 创建一个AsyncLoadingCache实例，配置了写入后10秒过期和最大容量为500  </span></span><br><span class="line">    <span class="comment">// buildAsync方法接收一个Function，用于定义如何异步加载缺失的键  </span></span><br><span class="line">    AsyncLoadingCache&lt;String, String&gt; cache = Caffeine.newBuilder()  </span><br><span class="line">        .expireAfterWrite(<span class="number">10</span>, TimeUnit.SECONDS)  </span><br><span class="line">        .maximumSize(<span class="number">500</span>)  </span><br><span class="line">        .buildAsync(k -&gt; createExpensiveGraph(k));  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 尝试获取键为&quot;hello&quot;的值，如果缓存中不存在，则会自动异步加载它  </span></span><br><span class="line">    CompletableFuture&lt;String&gt; future = cache.get(<span class="string">&quot;hello&quot;</span>);  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 阻塞等待异步操作完成，并获取结果  </span></span><br><span class="line">    <span class="comment">// 同样，实际应用中不建议直接调用future.get()，而是使用非阻塞的回调方式  </span></span><br><span class="line">    System.out.println(future.get());  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 模拟一个耗时的操作（例如查询数据库），并返回一个UUID字符串  </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">createExpensiveGraph</span><span class="params">(String key)</span> &#123;  </span><br><span class="line">    System.out.println(<span class="string">&quot;begin to query db...&quot;</span> + Thread.currentThread().getName());  </span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">        Thread.sleep(<span class="number">2000</span>); <span class="comment">// 模拟耗时操作  </span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </span><br><span class="line">        <span class="comment">// 异常处理  </span></span><br><span class="line">        Thread.currentThread().interrupt(); <span class="comment">// 恢复中断状态  </span></span><br><span class="line">    &#125;  </span><br><span class="line">    System.out.println(<span class="string">&quot;success to query db...&quot;</span>);  </span><br><span class="line">    <span class="keyword">return</span> UUID.randomUUID().toString();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="数据驱逐"><a href="#数据驱逐" class="headerlink" title="数据驱逐"></a>数据驱逐</h2><p>Caffeine提供以下几种剔除方式：基于大小、基于权重、基于时间、基于引用</p>
<h4 id="1-基于容量"><a href="#1-基于容量" class="headerlink" title="1. 基于容量"></a>1. 基于容量</h4><p>又包含两种, 基于size和基于weight权重</p>
<ul>
<li>基于size</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">LoadingCache&lt;String,String&gt; cache = Caffeine.newBuilder()</span><br><span class="line">			.maximumSize(<span class="number">500</span>)</span><br><span class="line">			.recordStats()</span><br><span class="line">			.build( k -&gt; UUID.randomUUID().toString());</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">600</span>; i++) &#123;</span><br><span class="line">			cache.get(String.valueOf(i));</span><br><span class="line">			<span class="keyword">if</span>(i&gt; <span class="number">500</span>)&#123;</span><br><span class="line">				<span class="type">CacheStats</span> <span class="variable">stats</span> <span class="operator">=</span> cache.stats();</span><br><span class="line">				System.out.println(<span class="string">&quot;evictionCount:&quot;</span>+stats.evictionCount());</span><br><span class="line">				System.out.println(<span class="string">&quot;stats:&quot;</span>+stats.toString());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>在循环开始时，缓存是空的。随着循环的进行，缓存将填充键从”0”到”599”的值。由于缓存的最大容量设置为500，当尝试添加第501个及以后的条目时，缓存将开始驱逐旧的条目以腾出空间。驱逐的策略取决于Caffeine的内部实现，通常是基于最近最少使用（LRU）的策略。  </p>
<p>因此，当<code>i</code>大于500时，开始打印驱逐计数和其他统计信息。这将帮助你了解驱逐是如何发生的，以及缓存的总体性能。  </p>
<ul>
<li>基于权重</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">LoadingCache&lt;Integer,String&gt; cache = Caffeine.newBuilder()</span><br><span class="line">			.maximumWeight(<span class="number">300</span>)</span><br><span class="line">			.recordStats()</span><br><span class="line">			.weigher((Weigher&lt;Integer, String&gt;) (key, value) -&gt; &#123;</span><br><span class="line">				<span class="keyword">if</span>(key % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">			&#125;)</span><br><span class="line">			.build( k -&gt; UUID.randomUUID().toString());</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">300</span>; i++) &#123;</span><br><span class="line">			cache.get(i);</span><br><span class="line">			<span class="keyword">if</span>(i&gt; <span class="number">200</span>)&#123;</span><br><span class="line">				System.out.println(cache.stats().toString());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>weigher(...)</code>: 定义一个<code>Weigher</code>函数，用于计算每个缓存条目的权重。在这个例子中，对于偶数键，权重为2；对于奇数键，权重为1。</p>
</li>
<li><p>这个循环尝试获取从0到299的整数键对应的缓存条目。  </p>
</li>
<li><p>当<code>i</code>大于200时，开始打印缓存的统计信息。由于权重是基于键的奇偶性来计算的，缓存可能会在达到最大权重限制（300）之前就开始驱逐条目。</p>
</li>
</ul>
<p>这个示例展示了如何使用Caffeine的权重功能来基于不同的策略管理缓存的容量。通过给偶数键分配更高的权重，缓存可能更早地驱逐这些键，从而保留更多的奇数键。这种策略在缓存中某些项比其他项更重要或更占用资源时非常有用。</p>
<h4 id="2-基于时间"><a href="#2-基于时间" class="headerlink" title="2.基于时间"></a>2.基于时间</h4><p>基于时间又分为四种: expireAfterAccess、expireAfterWrite、refreshAfterWrite、expireAfter</p>
<h4 id="3-基于弱-软引用"><a href="#3-基于弱-软引用" class="headerlink" title="3.基于弱&#x2F;软引用"></a>3.基于弱&#x2F;软引用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 允许GC时回收keys或values</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">demo</span><span class="params">()</span>&#123;</span><br><span class="line">		LoadingCache&lt;String,String&gt; cache = Caffeine.newBuilder()</span><br><span class="line">			.maximumSize(<span class="number">500</span>)</span><br><span class="line">			.expireAfterWrite(<span class="number">10</span>, TimeUnit.SECONDS)</span><br><span class="line">			.weakKeys()</span><br><span class="line">			.weakValues()</span><br><span class="line">			.build(k -&gt; UUID.randomUUID().toString());</span><br><span class="line"></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>Caffeine.weakKeys() 使用弱引用存储key。如果没有强引用这个key，则GC时允许回收该条目</p>
<p>Caffeine.weakValues() 使用弱引用存储value。如果没有强引用这个value，则GC时允许回收该条目</p>
<p>Caffeine.softValues() 使用软引用存储value, 如果没有强引用这个value，则GC内存不足时允许回收该条目</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">demo</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 使用软引用存储value,GC内存不够时会回收</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		LoadingCache&lt;String,String&gt; cache = Caffeine.newBuilder()</span><br><span class="line">			.maximumSize(<span class="number">500</span>)</span><br><span class="line">			.expireAfterWrite(<span class="number">10</span>, TimeUnit.SECONDS)</span><br><span class="line">			.softValues()<span class="comment">//注意没有softKeys方法</span></span><br><span class="line">			.build(k -&gt; UUID.randomUUID().toString());</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>Java4种引用的级别由高到低依次为：强引用 &gt; 软引用 &gt; 弱引用 &gt; 虚引用</p>
<h2 id="驱逐监听"><a href="#驱逐监听" class="headerlink" title="驱逐监听"></a>驱逐监听</h2><h4 id="1-手动触发删除"><a href="#1-手动触发删除" class="headerlink" title="1. 手动触发删除"></a>1. 手动触发删除</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// individual key</span></span><br><span class="line">cache.invalidate(key)</span><br><span class="line"><span class="comment">// bulk keys</span></span><br><span class="line">cache.invalidateAll(keys)</span><br><span class="line"><span class="comment">// all keys</span></span><br><span class="line">cache.invalidateAll()</span><br></pre></td></tr></table></figure>

<h4 id="2-被驱逐的原因"><a href="#2-被驱逐的原因" class="headerlink" title="2.被驱逐的原因"></a>2.被驱逐的原因</h4><p>EXPLICIT：如果原因是这个，那么意味着数据被我们手动的remove掉了<br>REPLACED：就是替换了，也就是put数据的时候旧的数据被覆盖导致的移除<br>COLLECTED：这个有歧义点，其实就是收集，也就是垃圾回收导致的，一般是用弱引用或者软引用会导致这个情况<br>EXPIRED：数据过期，无需解释的原因。<br>SIZE：个数超过限制导致的移除</p>
<h4 id="3-监听器"><a href="#3-监听器" class="headerlink" title="3.监听器"></a>3.监听器</h4><ol>
<li><p>创建缓存</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">LoadingCache&lt;String, String&gt; cache = Caffeine.newBuilder()  </span><br><span class="line">    .maximumSize(<span class="number">5</span>)  </span><br><span class="line">    .recordStats()  </span><br><span class="line">    .expireAfterWrite(<span class="number">2</span>, TimeUnit.SECONDS)  </span><br><span class="line">    .removalListener((String key, String value, RemovalCause cause) -&gt; &#123;  </span><br><span class="line">        System.out.printf(<span class="string">&quot;Key %s was removed (%s)%n&quot;</span>, key, cause);  </span><br><span class="line">    &#125;)  </span><br><span class="line">    .build(key -&gt; UUID.randomUUID().toString());</span><br></pre></td></tr></table></figure>

<ul>
<li><code>maximumSize(5)</code>: 设置缓存的最大容量为5个条目。</li>
<li><code>recordStats()</code>: 启用缓存统计功能。</li>
<li><code>expireAfterWrite(2, TimeUnit.SECONDS)</code>: 设置每个条目在被写入缓存后的生存期为2秒。在这2秒之后，条目可能会因过期而被自动驱逐。</li>
<li><code>removalListener(...)</code>: 设置一个移除监听器，当缓存中的条目被移除时（无论是由于过期、驱逐还是其他原因），这个监听器都会被触发。这里，它简单地打印出被移除的键和移除的原因。</li>
<li><code>build(key -&gt; UUID.randomUUID().toString())</code>: 创建一个新的<code>LoadingCache</code>实例，并提供一个函数来生成缺失键的默认值。对于任何缺失的键，这个函数会生成一个新的UUID字符串作为值。</li>
</ul>
</li>
<li><p>填充缓存并等待</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">15</span>; i++) &#123;  </span><br><span class="line">    cache.get(i+<span class="string">&quot;&quot;</span>);  </span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">        Thread.sleep(<span class="number">200</span>);  </span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这个循环尝试获取从”0”到”14”的字符串键对应的缓存条目。由于缓存的最大容量是5，当尝试添加第6个条目时，将开始驱逐旧的条目。</li>
<li><code>Thread.sleep(200);</code> 使主线程每次迭代后暂停200毫秒，以模拟一些工作负载。</li>
</ul>
</li>
<li><p>等待移除操作完成</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;  </span><br><span class="line">    Thread.sleep(<span class="number">2000</span>);  </span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>由于驱逐操作是异步执行的，主线程在填充缓存后暂停2秒，以便驱逐操作有足够的时间完成。这样，当程序结束时，更有可能看到由于过期而被移除的条目相关的输出。</li>
</ul>
</li>
</ol>
<p><strong>输出结果</strong>：<br>在控制台输出中，你将会看到一些由于缓存驱逐和过期而被移除的条目的信息。由于驱逐和过期是异步的，并且受到缓存访问模式和线程调度的影响，因此输出可能会有所不同。但通常，你会看到类似以下的输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Key 0 was removed (EXPIRED)  </span><br><span class="line">Key 1 was removed (EXPIRED)  </span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>这些输出表示哪些键由于过期而被移除了。此外，根据缓存的驱逐策略（例如，基于最近最少使用），还可能会看到其他由于驱逐而被移除的键。</p>
<h2 id="统计"><a href="#统计" class="headerlink" title="统计"></a>统计</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">demo</span><span class="params">()</span>&#123;</span><br><span class="line">		LoadingCache&lt;Integer,String&gt; cache = Caffeine.newBuilder()</span><br><span class="line">			.maximumSize(<span class="number">10</span>)</span><br><span class="line">			.expireAfterWrite(<span class="number">10</span>, TimeUnit.SECONDS)</span><br><span class="line">			.recordStats()</span><br><span class="line">			.build(key -&gt; &#123;</span><br><span class="line">				<span class="keyword">if</span>(key % <span class="number">6</span> == <span class="number">0</span> )&#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span>  UUID.randomUUID().toString();</span><br><span class="line">			&#125;);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">			cache.get(i);</span><br><span class="line">			printStats(cache.stats());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">			cache.get(i);</span><br><span class="line">			printStats(cache.stats());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printStats</span><span class="params">(CacheStats stats)</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;---------------------&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;stats.hitCount():&quot;</span>+stats.hitCount());<span class="comment">//命中次数</span></span><br><span class="line">		System.out.println(<span class="string">&quot;stats.hitRate():&quot;</span>+stats.hitRate());<span class="comment">//缓存命中率</span></span><br><span class="line">		System.out.println(<span class="string">&quot;stats.missCount():&quot;</span>+stats.missCount());<span class="comment">//未命中次数</span></span><br><span class="line">		System.out.println(<span class="string">&quot;stats.missRate():&quot;</span>+stats.missRate());<span class="comment">//未命中率</span></span><br><span class="line">		System.out.println(<span class="string">&quot;stats.loadSuccessCount():&quot;</span>+stats.loadSuccessCount());<span class="comment">//加载成功的次数</span></span><br><span class="line">		System.out.println(<span class="string">&quot;stats.loadFailureCount():&quot;</span>+stats.loadFailureCount());<span class="comment">//加载失败的次数,返回null</span></span><br><span class="line">		System.out.println(<span class="string">&quot;stats.loadFailureRate():&quot;</span>+stats.loadFailureRate());<span class="comment">//加载失败的百分比</span></span><br><span class="line">		System.out.println(<span class="string">&quot;stats.totalLoadTime():&quot;</span>+stats.totalLoadTime());<span class="comment">//总加载时间,单位ns</span></span><br><span class="line">		System.out.println(<span class="string">&quot;stats.evictionCount():&quot;</span>+stats.evictionCount());<span class="comment">//驱逐次数</span></span><br><span class="line">		System.out.println(<span class="string">&quot;stats.evictionWeight():&quot;</span>+stats.evictionWeight());<span class="comment">//驱逐的weight值总和</span></span><br><span class="line">		System.out.println(<span class="string">&quot;stats.requestCount():&quot;</span>+stats.requestCount());<span class="comment">//请求次数</span></span><br><span class="line">		System.out.println(<span class="string">&quot;stats.averageLoadPenalty():&quot;</span>+stats.averageLoadPenalty());<span class="comment">//单次load平均耗时</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>





<h2 id="整合SpringBoot"><a href="#整合SpringBoot" class="headerlink" title="整合SpringBoot"></a>整合SpringBoot</h2><ol>
<li>添加 spring-boot-starter-cache 依赖</li>
</ol>
<p>使用 spring-boot-starter-cache “Starter” 可以快速添加基本缓存依赖项。 starter 引入了 spring-context-support。如果我们手动添加依赖项，则必须包含 spring-context-support 才能使用 JCache 或 Caffeine 支持。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-cache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol>
<li>添加 caffeine 依赖</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.ben-manes.caffeine<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>caffeine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol>
<li>自定义缓存管理器</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Caffeine 缓存管理器</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> CacheManager <span class="title function_">caffeineCacheManager</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">SimpleCacheManager</span> <span class="variable">cacheManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleCacheManager</span>();</span><br><span class="line"></span><br><span class="line">    List&lt;CaffeineCache&gt; caches = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(CacheConsts.CacheEnum.values().length);</span><br><span class="line">    <span class="keyword">for</span> (CacheConsts.CacheEnum c : CacheConsts.CacheEnum.values()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c.isLocal()) &#123;</span><br><span class="line">            Caffeine&lt;Object, Object&gt; caffeine = Caffeine.newBuilder().recordStats().maximumSize(c.getMaxSize());</span><br><span class="line">            <span class="keyword">if</span> (c.getTtl() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                caffeine.expireAfterWrite(Duration.ofSeconds(c.getTtl()));</span><br><span class="line">            &#125;</span><br><span class="line">            caches.add(<span class="keyword">new</span> <span class="title class_">CaffeineCache</span>(c.getName(), caffeine.build()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cacheManager.setCaches(caches);</span><br><span class="line">    <span class="keyword">return</span> cacheManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>使用 @EnableCaching 注解开启缓存</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;io.github.xxyopen.novel.dao.mapper&quot;)</span></span><br><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NovelApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		SpringApplication.run(NovelApplication.class, args);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="keyword">public</span> CommandLineRunner <span class="title function_">commandLineRunner</span><span class="params">(ApplicationContext context)</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> args -&gt; &#123;</span><br><span class="line">			Map&lt;String, CacheManager&gt; beans = context.getBeansOfType(CacheManager.class);</span><br><span class="line">			log.info(<span class="string">&quot;加载了如下缓存管理器：&quot;</span>);</span><br><span class="line">			beans.forEach((k,v)-&gt;&#123;</span><br><span class="line">				log.info(<span class="string">&quot;&#123;&#125;:&#123;&#125;&quot;</span>,k,v.getClass().getName());</span><br><span class="line">				log.info(<span class="string">&quot;缓存：&#123;&#125;&quot;</span>,v.getCacheNames());</span><br><span class="line">			&#125;);</span><br><span class="line"></span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样我们就可以使用 Spring Cache 的注解（例如 @Cacheable）开发了。</p>
<h4 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h4><p>Spring Boot中用于缓存的注解主要有以下几个：</p>
<ol>
<li><p><code>@EnableCaching</code>: 用于开启Spring Boot的缓存支持。当在Spring Boot的配置类上使用此注解时，Spring Boot会查找并配置一个或多个缓存管理器（<code>CacheManager</code>），你可以使用Caffeine作为这个缓存管理器的实现。</p>
</li>
<li><p><code>@Cacheable</code>: 用于标记一个方法，使得其结果可以被缓存。当方法被调用时，如果缓存中已有对应的结果，则直接返回缓存中的结果，避免方法执行；如果缓存中没有结果，则执行方法并将结果存入缓存。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Cacheable(&quot;myCache&quot;)</span>  </span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getSomeData</span><span class="params">(String key)</span> &#123;  </span><br><span class="line">    <span class="comment">// ... 获取数据的逻辑  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>@CacheEvict</code>: 用于标记一个方法，使得在执行该方法时，指定的缓存项会被清除。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CacheEvict(value = &quot;myCache&quot;, key = &quot;#key&quot;)</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">evictSomeData</span><span class="params">(String key)</span> &#123;  </span><br><span class="line">    <span class="comment">// ... 删除数据的逻辑  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>@CachePut</code>: 用于标记一个方法，使得其结果总是会被缓存，无论缓存中是否已经存在对应的结果。这常用于需要更新缓存的场景。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CachePut(value = &quot;myCache&quot;, key = &quot;#key&quot;)</span>  </span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">updateSomeData</span><span class="params">(String key, String value)</span> &#123;  </span><br><span class="line">    <span class="comment">// ... 更新数据的逻辑  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>@Caching</code>: 用于组合多个缓存注解，例如，你可能想在执行一个方法后既更新缓存又清除其他缓存项。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Caching(  </span></span><br><span class="line"><span class="meta">    put = @CachePut(value = &quot;myCache&quot;, key = &quot;#key&quot;),  </span></span><br><span class="line"><span class="meta">    evict = @CacheEvict(value = &quot;anotherCache&quot;, key = &quot;#key&quot;)  </span></span><br><span class="line"><span class="meta">)</span>  </span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">complexCachingOperation</span><span class="params">(String key, String value)</span> &#123;  </span><br><span class="line">    <span class="comment">// ... 复杂的缓存操作逻辑  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>@CacheConfig</code>: 用于在类级别配置缓存相关的通用设置，例如缓存名称。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CacheConfig(cacheNames = &quot;myCache&quot;)</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> &#123;  </span><br><span class="line">    <span class="comment">// ... 缓存操作的方法  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>

    </article>
    
    <div class="read-nums">
      <!-- id 将作为查询条件 -->
      <span id="2024/03/24/本地缓存之王-Caffeine/" class="leancloud_visitors" data-flag-title="Your Article Title">
        <em class="post-meta-item-text">浏览量</em>
        <i class="leancloud-visitors-count"></i>
      </span>
    </div>
    <div class="comments-intro">
      <h2>评论区</h2>
      <p>欢迎你留下宝贵的意见，昵称输入QQ号会显示QQ头像哦~</p>
    </div>
    <div id="vcomments" class="vcomments"></div>
    
  </div>
  <div class="article-catelogue">
    <div class="article-catelogue--wrapper">
      <div class="catelogue catelogue-1">
        <h3>目录</h3>
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%8A%A0%E8%BD%BD"><span class="toc-number">1.</span> <span class="toc-text">数据加载</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Manual%E6%89%8B%E5%8A%A8"><span class="toc-number">1.0.1.</span> <span class="toc-text">1. Manual手动</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Loading%E8%87%AA%E5%8A%A8"><span class="toc-number">1.0.2.</span> <span class="toc-text">2. Loading自动</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Asynchronous-Manual%E5%BC%82%E6%AD%A5%E6%89%8B%E5%8A%A8"><span class="toc-number">1.0.3.</span> <span class="toc-text">3. Asynchronous Manual异步手动</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-Asynchronously-Loading%E5%BC%82%E6%AD%A5%E8%87%AA%E5%8A%A8"><span class="toc-number">1.0.4.</span> <span class="toc-text">4. Asynchronously Loading异步自动</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E9%A9%B1%E9%80%90"><span class="toc-number">2.</span> <span class="toc-text">数据驱逐</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%9F%BA%E4%BA%8E%E5%AE%B9%E9%87%8F"><span class="toc-number">2.0.1.</span> <span class="toc-text">1. 基于容量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%9F%BA%E4%BA%8E%E6%97%B6%E9%97%B4"><span class="toc-number">2.0.2.</span> <span class="toc-text">2.基于时间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%9F%BA%E4%BA%8E%E5%BC%B1-%E8%BD%AF%E5%BC%95%E7%94%A8"><span class="toc-number">2.0.3.</span> <span class="toc-text">3.基于弱&#x2F;软引用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A9%B1%E9%80%90%E7%9B%91%E5%90%AC"><span class="toc-number">3.</span> <span class="toc-text">驱逐监听</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%89%8B%E5%8A%A8%E8%A7%A6%E5%8F%91%E5%88%A0%E9%99%A4"><span class="toc-number">3.0.1.</span> <span class="toc-text">1. 手动触发删除</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%A2%AB%E9%A9%B1%E9%80%90%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">3.0.2.</span> <span class="toc-text">2.被驱逐的原因</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E7%9B%91%E5%90%AC%E5%99%A8"><span class="toc-number">3.0.3.</span> <span class="toc-text">3.监听器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%9F%E8%AE%A1"><span class="toc-number">4.</span> <span class="toc-text">统计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B4%E5%90%88SpringBoot"><span class="toc-number">5.</span> <span class="toc-text">整合SpringBoot</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3"><span class="toc-number">5.0.1.</span> <span class="toc-text">注解</span></a></li></ol></li></ol></li></ol>
      </div>
      
        <div class="catelogue catelogue-2">
          
            <p>
              <span>上一篇：</span>
              <a href="/2024/05/10/ControllerAdvice/">ControllerAdvice</a>
            </p>
           
          
            <p>
              <span>下一篇</span>
              <a href="/2024/03/11/Web实时消息推送详解/">Web实时消息推送详解</a>
            </p>
          
        </div>
      
    </div>
  </div>
</div>


<script>
  // var定义，避免pjax重新进来造成的重复声明错误
  var config = JSON.parse('{"enable":true,"appId":"Pf8zCXGEH1qsprnWfikVVujL-gzGzoHsz","appKey":"qOqoiUHhH1TGtLRUYURkLRQX","placeholder":"请留下你宝贵的意见吧~","meta":["nick"],"recordIP":true,"visitor":true,"enableQQ":true}')
  new Valine({
    el: '#vcomments',
    appId: config.appId,
    appKey: config.appKey,
    placeholder: config.placeholder,
    meta: config.meta,
    recordIP: config.recordIP,
    visitor: config.visitor,
    enableQQ: config.enableQQ,
    path: '2024/03/24/本地缓存之王-Caffeine/'
  })
</script>


<script>
  $(document).on('pjax:complete', function() {
    const tocs = document.querySelector('.toc')
    const links = tocs ? tocs.querySelectorAll('a') : []
    links.forEach(link => {
      link.addEventListener('click', e => {
        const href = decodeURIComponent(e.href)
        href.search(/#(.*)/)
        const id = RegExp.$1
        const target = document.querySelector('#' + id)
        const top = target.offsetTop
        document.documentElement.scrollTo({
          top: top - 100,
          behavior: 'smooth'
        })
        e.preventDefault()
      })
    })
  })
</script> 

</div>
      <div class="main-right-wrapper"><div class="main-right">
  <div class="main-right--board">
    <div class="main-right--title">
      <h5>公告栏</h5>
      <i class="iconfont icon-gonggao"></i>
    </div>
    <div class="main-right--content">
      Hello~大家好。我是iYaovo，欢迎你们来到我的博客小站，希望能在这里收获到有用的东西哦！ 
    </div>
  </div>

  <div id="aplayer" class="main-right--music"></div>

  <div class="operate-items">
    <div class="operate-item backtop">
      <i class="iconfont icon-huidaodingbu"></i>
      <span>回到顶部</span>
    </div>
    
    <div class="operate-item turn-comment hidden">
      <i class="iconfont icon-pinglun"></i>
      <span>查看评论</span>
    </div>
    
  </div>

  <div class="main-right--site">
    <div class="main-right--power">
      <p>Power By <a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/docs/">Hexo</a>.</p>
      <p>Theme：<a target="_blank" rel="noopener" href="https://github.com/Aizener/hexo-theme-cola">Cola.</a></p>
    </div>
    <p class="main-right--refer"><a target="_blank" rel="noopener" href="https://beian.miit.gov.cn/#/Integrated/index">蜀ICP备2022005384号-1</a> </p>
  </div>
</div>

<script>
  function setOperateItem () {
    const reg = /\d{4}\/\d{2}\/\d{2}\/.+/
    const path = location.pathname
    const operateDom = document.querySelector('.main-right .operate-items')
    const commentDom = document.querySelector('.turn-comment')
    const cateloguDom = document.querySelector('.article-catelogue > .article-catelogue--wrapper');

    if (commentDom) {
      if (reg.test(path) || path.match(/\/log\/.+/)) {
        commentDom.classList.remove('hidden')
        const newDom = operateDom.cloneNode(true);
        const _backtopDom = newDom.querySelector('.backtop');
        const _commentDom = newDom.querySelector('.turn-comment');
        _backtopDom.addEventListener('click', () => backTopEvent());
        _commentDom.addEventListener('click', () => commentDomEvent());
        cateloguDom.appendChild(newDom);
      } else {
        commentDom.classList.add('hidden')
      }
    }
  }

  setOperateItem()
  const musics = JSON.parse(`[{"name":"如果呢","artist":"郑润泽","url":"music/如果呢.mp3","cover":"https://pic.jitapai.com/wp-content/uploads/2021/06/2021062207282652.png"},{"name":"忘不掉的你","artist":"h3R3","url":"music/忘不掉的你.mp3","cover":"https://pic.jitapai.com/wp-content/uploads/2022/03/2022031407481132.jpg"},{"name":"明天","artist":"马思唯","url":"music/明天.mp3","cover":"https://tse4-mm.cn.bing.net/th/id/OIP-C.nzzINQpsCrL76xe4WYqmBQHaHa?pid=ImgDet&rs=1"}]`)
  const ap = new APlayer({
    container: document.querySelector('#aplayer'),
    audio: musics,
  })

  $(document).on('pjax:complete', function() {
    setOperateItem()
  })

  document.querySelector('.backtop').addEventListener('click', () => {
    backTopEvent();
  })
  const dom = document.querySelector('.turn-comment')
  dom && dom.addEventListener('click', () => {
    commentDomEvent();
  })

  function backTopEvent() {
    document.documentElement.scrollTo({
      top: 0,
      behavior: 'smooth'
    })
  }

  function commentDomEvent() {
    const commentDom = document.querySelector('.comments-intro')
    if (!commentDom) return
    const top = commentDom.offsetTop, height = commentDom.offsetHeight
    document.documentElement.scrollTo({
      top: top - 2 * height,
      behavior: 'smooth'
    })
  }
</script></div>
    </section>
  </div>
  <div id="progress" class="progress"></div>
  <div id="gray" class="gray"></div>

  <script>
    function initScroll () {
      document.addEventListener('scroll', () => {
        const doc = document.documentElement
        const scrollTop = doc.scrollTop
        const pageHeight = doc.offsetHeight
        const clientHeight = doc.clientHeight
        const ratio = scrollTop / (pageHeight - clientHeight)
        const progress = document.querySelector('#progress')
        const avatarImg = document.querySelector('.main-left--avatar')
        progress.style.width = (100 * ratio) + '%'
        avatarImg.style.transform = `rotate(${360 * ratio}deg)`
      })
    }

    const rootPath = "/"

    const checkAndSetArticlePageLayout = () => {
      const path = location.pathname.replace(rootPath, '');
      if (
        /^\/?\d{4}\/\d{2}\/\d{2}\/.*/.test(path) ||
        /^log\/.+/.test(path)
      ) {
        $('.main-container, .main-right, .main-right-wrapper').addClass('is-article')
      } else {
        $('.main-container, .main-right, .main-right-wrapper').removeClass('is-article')
      }
    }

    const gray = "none"
    const setGrayStyle = () => {
      if (gray === 'none') {
        return
      } else if (gray === 'index') {
        location.pathname === '/' ? $('#gray').show() : $('#gray').hide()
      } else if (gray === 'all') {
        $('#gray').show()
      }
    }
    setGrayStyle()


    window.onload = function () {
      checkAndSetArticlePageLayout()
      setTimeout(() => {
        $('#load').slideUp()
        $('#container').slideToggle()
        setTimeout(() => {
          initScroll();
        }, 500)
      }, 500)
    }
    
    let status = 0
    // 对所有链接跳转事件绑定pjax容器container
    $(document).pjax('a[target!=_blank]', '#main-container', {
      container: '#main-container',
      fragment: '#main-container',
      timeout: 8000
    })

    $(document).on('pjax:start', function() {
    })
    $(document).on('pjax:complete', function() {
      status = 0
      $('.main-container').addClass('to-up').on('animationend', function() {
        $(this).removeClass('to-up')
      })
      setGrayStyle()
      checkAndSetArticlePageLayout()
    })
    $(document).on('pjax:popstate', function() {
      status = -1
      checkAndSetArticlePageLayout()
    });
  </script>
</body>
</html>