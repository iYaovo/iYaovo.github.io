<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>我的技术与生活——java | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <link rel="shortcut icon" href="/imgs/shortcut-icon.ico" type="image/x-icon">
  <link rel="stylesheet" href="/css/public.css" />
  <link rel="stylesheet" href="/css/layout.css" />
  <link rel="stylesheet" href="/css/iconfont.css" />
  <link rel="stylesheet" href="/css/APlayer.min.css" />
  <script src="/js/APlayer.min.js"></script>
  <script src="/js/jquery.min.js"></script>
  <script src="/js/jquery.pjax.min.js"></script>

  <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
  <script>
    document.title = `我的技术与生活——java`
  </script>
<meta name="generator" content="Hexo 6.3.0"></head>

<style>
  .load {
    width: 100%;
    height: 100vh;
    background-color: rgb(37, 35, 40);
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    position: relative;
    z-index: 9999;
  }
  .load-circle {
    width: 80px;
    height: 80px;
    border: 8px solid orange;
    border-bottom-color: transparent;
    border-radius: 50%;
    display: flex;
    justify-content: center;
    align-items: center;
    animation: rotate 1s linear infinite;
    filter: drop-shadow(0 0 3px orange);
  }
  .load-circle-inner {
    width: 40px;
    height: 40px;
    border: 8px solid orange;
    border-top-color: transparent;
    border-radius: 50%;
    animation: rotate-reverse .5s linear infinite;
  }
  .load-text {
    margin-top: 20px;
    font-size: 24px;
    color: orange;
    display: flex;
  }
  .load-text span {
    margin: 0 5px;
    text-shadow: 5px 5px 5px orange;
    animation: move 1s linear infinite;
  }
  .load-text span:nth-child(1) {
    animation-delay: -0.6s;
  }
  .load-text span:nth-child(2) {
    animation-delay: -0.5s;
  }
  .load-text span:nth-child(3) {
    animation-delay: -0.4s;
  }
  .load-text span:nth-child(4) {
    animation-delay: -0.3s;
  }
  .load-text span:nth-child(5) {
    animation-delay: -0.2s;
  }
  .load-text span:nth-child(6) {
    animation-delay: -0.1s;
  }
  @keyframes rotate {
    0% { transform: rotate(0); }
    100% { transform: rotate(360deg); }
  }
  @keyframes rotate-reverse {
    0% { transform: rotate(0); }
    100% { transform: rotate(-360deg); }
  }
  @keyframes move {
    0% { transform: translateY(0%) rotate(0) scale(1); }
    20% { transform: translateY(20%) rotate(10deg) scale(1.2); }
    80% { transform: translateY(-10%) rotate(-20deg) scale(.8);}
    100% { transform: translateY(0) rotate(0) scale(1); }
  }

  .progress {
    position: fixed;
    left: 0; top: 0;
    width: 0;
    height: 3px;
    background-color: green;
    transition: all cubic-bezier(0.215, 0.610, 0.355, 1) .1s;
    z-index: 9999;
  }

  .to-up {
    animation: toUp .5s 1;
  }
  .gray {
    position: fixed;
    left: 0;
    top: 0;
    width: 100%;
    height: 100vh;
    z-index: 9999;
    display: none;
    pointer-events: none;
    background-color: #000;
    mix-blend-mode: color;
  }
  @keyframes toUp {
    from { transform: translateY(15px); opacity: 0; }
    to { transform: translateY(0) ; opacity: 1; }
  }
</style>
<body>
  <div id="load" class="load">
    <div class="load-circle">
      <div class="load-circle-inner"></div>
    </div>
    <p class="load-text">
      <span>L</span>
      <span>O</span>
      <span>A</span>
      <span>D</span>
      <span>I</span>
      <span>N</span>
      <span>G</span>
    </p>
  </div>
  <div id="container" class="container w-100 vh-100" style="display: none;">
    <header class="header">
  <div class="header-wrapper">
    <div class="header-left">
      <div class="header-search">
        <input id="search-input" type="text" class="header-search--input" placeholder="请输入要检索的文章标题" />
        <span id="search-btn" class="header-search--icon"><i class="iconfont icon-sousuo"></i></span>
      </div>
      <div id="search-layer" class="header-search--layer hidden">
        <p class="title">
          <span>以下是搜索内容：</span>
          <span id="close-layer-btn">关闭</span>
        </p>
        <ul>
        </ul>
      </div>
    </div>
    <div class="header-right">
      <ul class="header-menu">
        <li>
          <a href="http://example.com/">
            <i class="header-menu--icon iconfont icon-shouye"></i>
            <span class="header-menu--span">首页</span>
          </a>
        </li>
        <li>
          <a href="http://example.com/log">
            <i class="header-menu--icon iconfont icon-rizhi"></i>
            <span class="header-menu--span">日志</span>
          </a>
        </li>
        <li>
          <a href="http://example.com/link">
            <i class="header-menu--icon iconfont icon-youqinglianjie"></i>
            <span class="header-menu--span">友情链接</span>
          </a>
        </li>
        <li>
          <a href="http://example.com/about">
            <i class="header-menu--icon iconfont icon-guanyuwomen"></i>
            <span class="header-menu--span">关于我</span>
          </a>
        </li>
      </ul>
    </div>
  </div>
</header>

<script>
  const ipt = document.querySelector('#search-input')
  const btn = document.querySelector('#search-btn')
  const layer = document.querySelector('#search-layer')
  const posts = JSON.parse(`[{"title":"java","path":"2023/08/31/java-0/"},{"title":"图片上传","path":"2023/09/01/图片上传-1/"},{"title":"","path":"2023/10/17/代码随想录-3/"}]`)
  ipt.addEventListener('keyup', e => {
    if (e.key === 'Enter') {
      handleSearch()
    }
  })
  btn.addEventListener('click', () => {
    handleSearch()
  })

  document.querySelector('#close-layer-btn').addEventListener('click', () => {
    layer.classList.toggle('hidden')
  })

  function handleSearch() {
    if (ipt.value.trim() === '') {
      return
    }
    let html = ''
    const targetPosts = posts.filter(post => post.title.includes(ipt.value))
    targetPosts.forEach(post => {
      html += `
        <li>
          <div>
            <a href="/${post.path}">${post.title.replace(new RegExp(ipt.value), `<span>${ipt.value}</span>`)}</a>
          </div>
          <img src="${post.cover || '/imgs/default-cover.webp' }" />
        </li>
      `
    })
    if (html.trim () === '') {
      html += '<p class="empty">没有搜索到内容</p>'
    }
    layer.querySelector('ul').innerHTML = html
    layer.classList.remove('hidden')
  }
</script> 
    <section id="main" class="main">
      <div class="main-left-wrapper">
<div class="main-left">
  <div class="main-left--block">
    <div class="main-left--info">
      <img src="/imgs/avatar.jpg"" class="main-left--avatar" />
      <div class="main-left--intro">
        <p class="main-left--name">iYaovo</p>
        <div class="main-left--tags">
          <span class="main-left--tag">中二</span>
          <span class="main-left--tag">宅</span>
        </div>
      </div>
    </div>
  
    <div>
      <div class="main-left--motto">
        <p>“时间不站在你那边”</p>
        <p></p>
      </div>
      <div class="main-left--github">
        <span class="line"></span>
        <a target="_blank" rel="noopener" href="https://github.com/iYaovo"><i class="logo iconfont icon-github-fill"></i></a>
        <span class="line"></span>
      </div>
      <div class="main-left--statics">
        <a href="/categories">
          <div>
            <span>2</span>
            <span>分类</span>
          </div>
        </a>
        <a href="/tags">
          <div>
            <span>1</span>
            <span>标签</span>
          </div>
        </a>
        <a href="/archives">
          <div>
            <span>3 </span>
            <span>归档</span>
          </div>
        </a>
      </div>
    </div>
  </div>

  <div class="main-left--block">
    <ul class="main-left--menu">
      
        <li>
          <a href="/">
            <span class="header-menu--span">小站首页</span>
            <i class="header-menu--icon iconfont icon-shouye"></i>
          </a>
        </li>
      
        <li>
          <a href="/log">
            <span class="header-menu--span">个人日志</span>
            <i class="header-menu--icon iconfont icon-rizhi"></i>
          </a>
        </li>
      
        <li>
          <a href="/link">
            <span class="header-menu--span">友情链接</span>
            <i class="header-menu--icon iconfont icon-youqinglianjie"></i>
          </a>
        </li>
      
        <li>
          <a href="/about">
            <span class="header-menu--span">关于自己</span>
            <i class="header-menu--icon iconfont icon-guanyuwomen"></i>
          </a>
        </li>
      
        <li>
          <a href="/tools">
            <span class="header-menu--span">我的工具</span>
            <i class="header-menu--icon iconfont icon-gongju"></i>
          </a>
        </li>
      
    </ul>
  </div>

  <div class="main-left--block">
    <div class="main-left--site">
      <h5 class="main-left--title">
        <span>站点信息</span>
        <i class="iconfont icon-zhandian"></i>
      </h5>
      <p class="main-left--subtitle">
        <span>文章数目：</span>
        <span>3 篇</span>
      </p>
      <p class="main-left--subtitle">
        <span>最近动态：</span>
        <span>今天</span>
      </p>
      <p class="main-left--subtitle">
        <span>上线时间：</span>
        <span>57天</span>
      </p>
      <p class="main-left--subtitle">
        <span>当前版本：</span>
        <span>v1.0.2</span>
      </p>
    </div>
  </div>
</div></div>
      <div id="main-container" class="main-container">


  <link rel="stylesheet" href="/css/partial/article.css" />

<div class="article-container">
  <div class="article">
    <h1 class="article-title">java</h1>
    <div class="article-info">
      <div class="article-info--item">
        <div class="article-info--info">
          
          <div class="article-info--categories">
            <span>分类：</span>
            <a class="category-link" href="/categories/%E9%BB%98%E8%AE%A4%E5%88%86%E7%B1%BB/">默认分类</a>
          </div>
          
          
          <div class="article-info--tags">
            <span>标签：</span>
            <a class="tag-link" href="/tags/backend/" rel="tag">backend</a>
          </div>
          
          <p class="article-info--date">日期：2023-08-31 16:52:15</p>
        </div>
        <img src="/imgs/default-cover.webp" alt="" class="article-cover">
      </div>
    </div>
    <article class="article-content markdown-body">
      <h1 id="JAVA开发环境的搭建"><a href="#JAVA开发环境的搭建" class="headerlink" title="JAVA开发环境的搭建"></a>JAVA开发环境的搭建</h1><h2 id="常用的Dos命令"><a href="#常用的Dos命令" class="headerlink" title="常用的Dos命令"></a>常用的Dos命令</h2><p> win+r打开Dos命令窗口</p>
<h3 id="什么是Dos命令"><a href="#什么是Dos命令" class="headerlink" title="什么是Dos命令"></a>什么是Dos命令</h3><p>在最初的计算机中没有图形界面，也就是说通过Dos命令窗口可以完全完成文件的新建、编辑、保存、删除等一系列操作。</p>
<h3 id="mkdir-abc"><a href="#mkdir-abc" class="headerlink" title="mkdir abc"></a>mkdir abc</h3><p>创建一个目录，起名abc</p>
<h3 id="在Dos窗口中怎么复制内容"><a href="#在Dos窗口中怎么复制内容" class="headerlink" title="在Dos窗口中怎么复制内容"></a>在Dos窗口中怎么复制内容</h3><p>左键选中要复制的内容，右键点击一次，内容就到了剪贴板了。</p>
<h3 id="切换盘符"><a href="#切换盘符" class="headerlink" title="切换盘符"></a>切换盘符</h3><p>直接输入盘符即可。</p>
<p>c：回车  就到了c盘，同理其他也一样。</p>
<h3 id="切换目录"><a href="#切换目录" class="headerlink" title="切换目录"></a>切换目录</h3><p>使用cd命令来完成目录的切换。</p>
<p>cd+路径</p>
<p>路径可以是相对路径也可以是绝对路径。</p>
<p><strong>cd..回到上级目录</strong></p>
<p><strong>cd  \ 回到根目录</strong></p>
<p><strong>cd+.代表当前路径</strong></p>
<p> <strong>cls清屏</strong></p>
<p> <strong>dir查看当前目录下有啥东西</strong></p>
<p> <strong>exit 退出Dos命令窗口</strong></p>
<p> <strong>del删除一个或者多个文件</strong></p>
<p><strong>del 1.txt 就删除了他</strong></p>
<p>*<em>del <em>.txt 就删除所有txt文件</em></em></p>
<p>t1.class</p>
<p>t1.glass</p>
<p>del *ass 这个命令会将上述两个文件都删除。</p>
<p> 怎么查看本机的IP地址</p>
<p>在命令框输入ipconfig（可查询ip地址的配置信息）</p>
<p>ipconfig &#x2F;all  可查看更详细信息</p>
<h3 id="怎么查看两台计算机可以正常通信"><a href="#怎么查看两台计算机可以正常通信" class="headerlink" title="怎么查看两台计算机可以正常通信"></a>怎么查看两台计算机可以正常通信</h3><p>ping IP地址</p>
<p>ping 域名</p>
<p>例如 ping <a target="_blank" rel="noopener" href="http://www.baidu.com/">www.baidu.com</a></p>
<p>后面加个-t   就一直ping，直到人操作终止。</p>
<p>一直ping的目的是查看网络是否稳定。</p>
<p>在一个DOS窗口中一个命令一直执行，想结束</p>
<p>用ctrl+c结束。</p>
<p>DOS命令窗口中，可以使用tab键自动补全。</p>
<p>DOS命令窗口中，使用上下箭头可以翻出历史记录。</p>
<h3 id="电脑快捷键"><a href="#电脑快捷键" class="headerlink" title="电脑快捷键"></a>电脑快捷键</h3><p>win+d 显示桌面</p>
<p>win+l 锁屏</p>
<h3 id="文本快捷键"><a href="#文本快捷键" class="headerlink" title="文本快捷键"></a>文本快捷键</h3><table>
<thead>
<tr>
<th>ctrl+s</th>
<th>保存</th>
</tr>
</thead>
<tbody><tr>
<td>ctrl+z</td>
<td>撤销</td>
</tr>
<tr>
<td>ctrl+y</td>
<td>重做</td>
</tr>
<tr>
<td>ctrl+a</td>
<td>全选</td>
</tr>
<tr>
<td>fn+home</td>
<td>光标回到行首</td>
</tr>
<tr>
<td>fn+end</td>
<td>光标回到行尾</td>
</tr>
<tr>
<td>ctrl+fn+home</td>
<td>光标回到文章开始</td>
</tr>
<tr>
<td>ctrl+fn+end</td>
<td>光标回到文章末尾</td>
</tr>
<tr>
<td>shift+上方向键或下方向键</td>
<td>选中一行</td>
</tr>
<tr>
<td>鼠标双击</td>
<td>选中一个单词</td>
</tr>
<tr>
<td>ctrl+shift+右箭头或左箭头</td>
<td>选中一个单词</td>
</tr>
<tr>
<td>鼠标连击三次</td>
<td>选中一行</td>
</tr>
<tr>
<td>ctrl+f</td>
<td>查找</td>
</tr>
</tbody></table>
<h2 id="java语言特性"><a href="#java语言特性" class="headerlink" title="java语言特性"></a>java语言特性</h2><h3 id="简单性"><a href="#简单性" class="headerlink" title="简单性"></a>简单性</h3><p>java中真正操作内存的是：JVM（java虚拟机）</p>
<p>所有java程序都是运行在java虚拟机当中的。</p>
<p>而java虚拟机执行过程中再去操作内存。</p>
<p>而c语言时可以直接通过指针操作内存的。</p>
<p>因此</p>
<p>java优点：简单，不容易导致内存泄漏</p>
<p>缺点：效率问题。</p>
<p>java语言底层是c++，JVM是用c++写好的的一个虚拟的电脑。</p>
<p>安装了JDK后，JVM就安装好了。</p>
<h4 id="计算机重要部件"><a href="#计算机重要部件" class="headerlink" title="计算机重要部件"></a>计算机重要部件</h4><p><strong>cpu</strong>：中央处理器，相当于人类的大脑，负责发送并执行指令。</p>
<p>cpu负责计算，但计算过程中有数据需要临时找个空间存储一下：就需要内存</p>
<p><strong>内存</strong></p>
<p>程序执行过程中临时数据存储空间。</p>
<p>断电之后数据就消失了。</p>
<p><strong>硬盘</strong></p>
<p>持久化设备。</p>
<p><strong>主板</strong></p>
<p>相当于人的躯干，是一个载体。</p>
<h4 id="java是堪称完全面向对象的"><a href="#java是堪称完全面向对象的" class="headerlink" title="java是堪称完全面向对象的"></a>java是堪称完全面向对象的</h4><p>面向对象更容易让人理解，使复杂问题简单化。</p>
<h3 id="健壮性"><a href="#健壮性" class="headerlink" title="健壮性"></a>健壮性</h3><p>java中有一种机制</p>
<p>自动垃圾回收机制（GC机制）</p>
<p>JVM负责调度GC机制，程序员不需要干涉。</p>
<h4 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h4><p>jvm是java虚拟机，用c++写好的，java程序实际没有直接和操作系统打交道。</p>
<p>java程序写出来后是一样的，windows上的jvm和mac上的不同，然后就可将java程序翻译成Windows和mac分别能看懂的语言。</p>
<p><strong>jvm屏蔽了操作系统之间的差异</strong></p>
<p>jvm是安装jdk的时候自带的。</p>
<p>因此jdk也分Windows和mac</p>
<h3 id="可移植性-跨平台"><a href="#可移植性-跨平台" class="headerlink" title="可移植性&#x2F;跨平台"></a>可移植性&#x2F;跨平台</h3><p>java语言只要编写一次，可以做到到处运行。</p>
<p>jvm这种机制实现了跨平台。</p>
<p>优点：一次编写到处运行。</p>
<p>缺点：麻烦，运行java程序必须先有一个jvm。</p>
<h4 id="JDK、JRE、JVM三者之间的关系"><a href="#JDK、JRE、JVM三者之间的关系" class="headerlink" title="JDK、JRE、JVM三者之间的关系"></a>JDK、JRE、JVM三者之间的关系</h4><p>jdk：java开发工具箱</p>
<p>jre：java运行环境</p>
<p>jvm：java虚拟机</p>
<p>jvm不能独立安装，jdk包括jre，jre包括jvm。</p>
<p><strong>安装jdk，jre自动安装，jvm也自动安装</strong></p>
<p><strong>安装jre，jvm也自动安装</strong></p>
<p><strong>假如一个电脑只需将程序跑起来，那就值安装jre就行，不需要jdk</strong></p>
<h4 id="java从编译到运行"><a href="#java从编译到运行" class="headerlink" title="java从编译到运行"></a>java从编译到运行</h4><p>程序员写的java代码无法被jvm识别。必须经过编译变成字节码，才能被jvm识别。</p>
<p>java代码变成字节码的过程叫 <strong>编译</strong></p>
<p>java代码被称为源代码。</p>
<p><strong>字节码可以到不同系统去使用，因为java是跨平台的。</strong></p>
<p>放源代码的文件扩展名是 xxx.java</p>
<p>编译生成的字节码文件扩展名是：xxx.class</p>
<p>1个java文件可编译生成多个class文件。</p>
<p><strong>字节码不是二进制文件</strong></p>
<p>如果是的话，就不需要jvm什么事情了。</p>
<p><strong>需要使用的两个命令</strong></p>
<p>javac命令，负责编译</p>
<p>java命令，负责运行</p>
<p><strong>小插曲</strong></p>
<p>xxx.java经过编译后生成了A.class B.class C.class，那么我们称A是一个类，B是一个类，C是一个类。</p>
<h2 id="java使用"><a href="#java使用" class="headerlink" title="java使用"></a>java使用</h2><h3 id="java下载以及环境变量配置"><a href="#java下载以及环境变量配置" class="headerlink" title="java下载以及环境变量配置"></a>java下载以及环境变量配置</h3><p>javac -version命令可查看java版本</p>
<p><strong>path环境变量作用</strong></p>
<p>告诉Windows系统去哪里找这个命令文件。</p>
<h3 id="javac命令怎么用"><a href="#javac命令怎么用" class="headerlink" title="javac命令怎么用"></a>javac命令怎么用</h3><p>格式： javac java源文件的路径。</p>
<p>路径可以是绝对或相对。</p>
<p>javac 然后把java文件拖进命令框也可以。</p>
<p><strong>除了win+r进入DOS命令框以外，还可以在文件夹地址栏输入cmd，这样的好处是进入DOS命令框后，路径深入，更好找到想找的java文件</strong></p>
<h3 id="java命令"><a href="#java命令" class="headerlink" title="java命令"></a>java命令</h3><p>java+类名</p>
<p><strong>使用时</strong></p>
<p>先用cd命令找到.class文件所在路径，然后在java+类名</p>
<h3 id="classpath环境变量"><a href="#classpath环境变量" class="headerlink" title="classpath环境变量"></a>classpath环境变量</h3><p>进行</p>
<p><strong>java+类命令后</strong></p>
<p>第一步：会启动JVM（java虚拟机）</p>
<p>第二步：jvm启动之后，jvm会自动启动类加载器classloader</p>
<p>作用：负责去硬盘找类对应的字节码文件。</p>
<p>第三步：找不到就报错。</p>
<p>找到了，类加载器会将该字节码文件装载到jvm中，启动解释器将字节码解释为二进制码，操作系统执行二进制码和硬件交互。</p>
<p>类加载器找的是当前路径下的类文件。</p>
<p><strong>能不能给加载器一个路径，直接让他去别的地方找？？</strong></p>
<p>但需要classpath</p>
<p>classpath环境变量不属于Windows操作系统，是java特有的。</p>
<p>配置classpath 后，java命令只会去配置classpath的文件夹找，不会在当前路径找，所以不如不配。</p>
<p>目前不需要classpath，理解即可、</p>
<p><strong>java后面直接加java源文件路径，可以直接运行，但是这样不会生成class文件，现在没必要这么使用</strong></p>
<h2 id="java注释"><a href="#java注释" class="headerlink" title="java注释"></a>java注释</h2><p>&#x2F;&#x2F;单行</p>
<p>&#x2F;* *&#x2F;多行</p>
<p>&#x2F;**</p>
<ul>
<li></li>
<li></li>
<li></li>
</ul>
<p>*&#x2F;</p>
<p>这种叫javadoc注释：这里的注释信息可以自动被javadoc.exe命令解析提取并生成到帮助文档中。</p>
<h2 id="类体"><a href="#类体" class="headerlink" title="类体"></a>类体</h2><p>1.在java中任何有效代码必须写到类体中，最外层必须是一个类的定义。</p>
<p>2.public表示公开，class表示定义一个类，test是一个类名</p>
<p>例 public class test{</p>
<p>}</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="main方法"><a href="#main方法" class="headerlink" title="main方法"></a>main方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main（String[] args）&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>也可以</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main（String args[]）&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>整个这一块被称为main方法（程序的入口）</p>
<p>main方法也可以叫做主方法。</p>
<p>注意：方法必须放在类体中，不得放到类体外。</p>
<p>任何一个程序都要有入口。</p>
<p>能再来一次main方法吗？</p>
<p>不能，会有语法错误。</p>
<p><strong>main方法中，arge可以改名字，对于主方法来说，只有这个位置可以改，</strong></p>
<p>java语句必须写在方法里。</p>
<p>100和“100”不一样</p>
<p>+-*&#x2F;也都和c语言一样。</p>
<h3 id="class"><a href="#class" class="headerlink" title="class"></a>class</h3><p>一个java文件中</p>
<p>class A{</p>
<p>}</p>
<p>class B{</p>
<p>}</p>
<p>可以运行吗？</p>
<p>可以的。并且生成两个class文件。</p>
<p><strong>结论一：一个java源文件中可以定义多个class</strong></p>
<p><strong>结论二：public的类不是必须的。</strong></p>
<p><strong>结论三</strong>：public的类必须和源文件名保持一致</p>
<p><strong>结论四：public的类也只能有一个</strong></p>
<p>class t1{</p>
<p>public static void main（String[] arge）</p>
<p>system.out.println（“t1”）；</p>
<p>}</p>
<p>class t2{</p>
<p>public static void main（String[] arge）</p>
<p>system.out.println（“t2”）；</p>
<p>}</p>
<p>class t3{</p>
<p>public static void main（String[] arge）</p>
<p>system.out.println（“t3”）；</p>
<p>}</p>
<p>要想运行这些，java+类名时  类名用t1，t2，t3即可</p>
<p>(不过一般不这样，只是为了理解)</p>
<p>一般软件的入口只有一个。</p>
<h3 id="public-class"><a href="#public-class" class="headerlink" title="public class"></a>public class</h3><p>必须和java文件名相同。</p>
<h1 id="标识符与关键字"><a href="#标识符与关键字" class="headerlink" title="标识符与关键字"></a>标识符与关键字</h1><h2 id="标识符可以标识什么"><a href="#标识符可以标识什么" class="headerlink" title="标识符可以标识什么"></a>标识符可以标识什么</h2><p> 类名，变量名，方法名，变量名等等</p>
<p>数字，字母，下划线。以及￥,标识符也可以是中文。</p>
<p>关键字不能做标识符</p>
<h2 id="可以命名123-java吗"><a href="#可以命名123-java吗" class="headerlink" title="可以命名123.java吗"></a>可以命名123.java吗</h2><p>可以，在Windows操作系统中文件名叫做：123.java没问题。</p>
<p>只不过在123.java文件中无法定义public的类。</p>
<p>因为类名不能以数字开头。</p>
<h2 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h2><p>见名起意</p>
<p>驼峰</p>
<p><strong>类名，接口特殊要求</strong></p>
<p>类名接口首字母大写，后面每个单词首字母大写。</p>
<p><strong>变量名，方法名</strong></p>
<p>首字母小写，后面每个单词首字母大写。</p>
<p><strong>所有常量名全部大写，单词单词之间采用下划线衔接</strong></p>
<h2 id="关键字"><a href="#关键字" class="headerlink" title=".关键字"></a>.关键字</h2><p>蓝色字体，小写，是关键字。</p>
<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><h2 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h2><p>和c一样</p>
<h2 id="变量-1"><a href="#变量-1" class="headerlink" title="变量"></a>变量</h2><p>变量名首字母小写，后面字母大写</p>
<p>与c语言不同，java<strong>变量必须初始化（成员变量例外）</strong></p>
<h2 id="变量分类"><a href="#变量分类" class="headerlink" title="变量分类"></a>变量分类</h2><p>在方法体当中声明的变量，叫局部变量。</p>
<p>在方法体之外的叫成员变量。</p>
<p>类似于c语言全局变量和局部变量。</p>
<p>与c语言相同。</p>
<p>局部变量只在方法体内有效，方法体执行结束变量的内存就释放了。</p>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h2><p>数据类型分为两类在java中</p>
<h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p>整数型：byte，short，int，long</p>
<p>浮点型：float，double</p>
<p>布尔型：true，false</p>
<p>字符型：用单引号括起来</p>
<h3 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h3><p>String属于引用数据类型</p>
<p>引用数据类型后期面向对象的时候才会接触。</p>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>float double 以及 int long这些占据的空间不同</p>
<h3 id="占用字节数量"><a href="#占用字节数量" class="headerlink" title="占用字节数量"></a>占用字节数量</h3><table>
<thead>
<tr>
<th>类型</th>
<th>占用字节数量</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>1</td>
</tr>
<tr>
<td>short</td>
<td>2</td>
</tr>
<tr>
<td>int</td>
<td>4</td>
</tr>
<tr>
<td>long</td>
<td>8</td>
</tr>
<tr>
<td>float</td>
<td>4</td>
</tr>
<tr>
<td>double</td>
<td>8</td>
</tr>
<tr>
<td>boolean</td>
<td>1</td>
</tr>
<tr>
<td>char</td>
<td>2</td>
</tr>
</tbody></table>
<h3 id="取值范围"><a href="#取值范围" class="headerlink" title="取值范围"></a>取值范围</h3><p>byte是[-128~127]，可以标识256个不同数字。</p>
<p>byte类型最大值是怎么算出来的？？？</p>
<p> btye是一个字节，8个比特位。</p>
<p>byte最大值为 01111111</p>
<p>因为二进制位最左边的是符号位，为0时为正数，1时为负数。</p>
<p><strong>所以byte最大为01111111</strong></p>
<p>则是256</p>
<p><strong>需要记忆的取值范围</strong></p>
<p>byte -128~127  可以标识256个不同数字</p>
<p>short -32768~32767 可以标识65536个不同数字</p>
<p>int -2147483648~214783647  </p>
<p>char 0~65535   可以标识65536个不同数字</p>
<h3 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h3><p>规定了一系列的文字对应的二进制</p>
<p>最开始支持的文字是英文，英文对应的字符编码方式是：ASCII码</p>
<p>ASCII采用1byte进行存储，因为英文字母只有26个，1byte足以表示。</p>
<p>‘a’–&gt;97</p>
<p>‘b’–&gt;98</p>
<p>‘A’–&gt;65</p>
<p>‘B’–&gt;66</p>
<p>‘0’–&gt;48(文字0)</p>
<p>‘1’–&gt;49</p>
<p>中文编码方式：GB2312&lt;GBK&lt;GB18030 (简体中文)</p>
<p>繁体中文：big5</p>
<p>java为了支持全球所有文字，采用<strong>unicode</strong>编码。</p>
<p>具体的实现包括：UTF-8 UTF-16 UTF-32</p>
<h3 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h3><p>\t \n与c一样</p>
<p><strong>输出时</strong></p>
<p>System.out.println()这种是输出后换行</p>
<p>System.out.print()这种输出后不换行。</p>
<p><strong>想在控制台输出一个\字符咋办</strong></p>
<p>System.out.println(‘\ ‘) 不行</p>
<p>因为\会把 ‘转义</p>
<p>因此就</p>
<p>System.out.println(‘ \ \ ‘)</p>
<p>这样做\会把\转化为普通的\，就输出了。</p>
<p><strong>同理，想在控制台输出一个’也一样</strong></p>
<p><strong>想输出”test”</strong></p>
<p>System.out.println(“\“test\””)</p>
<p>或者 内引号用中文引号。</p>
<p>\u是  表示后面的是一个字符的unicode编码</p>
<p>System.out.println(‘\ u4e2d’)</p>
<p>本身’’里只能放一个字符，但\u会变成unicode编码，4e2d输出后是中字。</p>
<h3 id="进制"><a href="#进制" class="headerlink" title="进制"></a>进制</h3><p>十进制 10</p>
<p>八进制 010</p>
<p>十六进制 0x10</p>
<p>二进制 0b10</p>
<h3 id="整数型被默认当做int处理"><a href="#整数型被默认当做int处理" class="headerlink" title="整数型被默认当做int处理"></a>整数型被默认当做int处理</h3><p>想被当做long处理，则在数字后面写L。</p>
<h3 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h3><p>long i&#x3D;200；</p>
<p>200虽然被当做int，但是可以自动转换为long（没超过范围就可以）</p>
<p><strong>long i&#x3D;2147483645</strong></p>
<p>编译器会报错吗？？？</p>
<p>会，因为java中会字面量被当做int处理，2147483645就是int，然后超出范围了</p>
<p>byte&lt;short（char）&lt;int&lt;long&lt;float&lt;double </p>
<h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><p>long x&#x3D;100L</p>
<p>int y&#x3D;（int）x</p>
<p>才能编译通过，但会损失精度</p>
<p>byte b&#x3D;300可以编译通过吗？？？</p>
<p>不行，300的int要转换为byte，必须强制类型转换</p>
<p>int类型的300 是  00000000 00000000 00000001 00101100</p>
<p>byte自动砍掉前三字节，00101100就是44</p>
<h3 id="整数能否直接赋值给char"><a href="#整数能否直接赋值给char" class="headerlink" title="整数能否直接赋值给char"></a>整数能否直接赋值给char</h3><p>char x&#x3D;97</p>
<p>输出结果为’a’</p>
<p>将整数赋值给char，会自动转化为char型。</p>
<h3 id="二进制补码"><a href="#二进制补码" class="headerlink" title="二进制补码"></a>二进制补码</h3><p>计算机在任何情况下都只能识别二进制</p>
<p>计算机在底层存储数据时，一律存储的是二进制的补码形式。</p>
<h4 id="什么是补码"><a href="#什么是补码" class="headerlink" title="什么是补码"></a>什么是补码</h4><p>二进制包括：原码，反码，补码</p>
<p>对于一个正数来说：原码，补码，反码是同一个，完全相同。</p>
<p>对一个负数来说：</p>
<p>byte i&#x3D;-1</p>
<p>原码 10000001</p>
<p>反码 11111110（符号位不变，其他位取反）</p>
<p>补码 11111111（反码+1）</p>
<p><strong>byte b&#x3D;（byte）150</strong></p>
<p>150转换为二进制   00000000 00000000 00000000 10010110</p>
<p>byte后 剩下 10010110</p>
<p>（计算机中存储的永远都是二进制补码形式）</p>
<p>所以 反码 &#x3D;补码-1 ：10010101</p>
<p>原码：11101010</p>
<p>所以b&#x3D;-106</p>
<h3 id="char-byte"><a href="#char-byte" class="headerlink" title="char+byte"></a>char+byte</h3><p>char c1&#x3D;’a’</p>
<p>byte b&#x3D;1</p>
<p>输出c1+b为一个int型的98</p>
<p><strong>结论</strong>：byte char short做混合运算的时候，各自先转换成int再做运算。</p>
<p>short s&#x3D;c1+b（报错） 与 short k&#x3D;98（正常） </p>
<p>为什么？？？</p>
<p>第二种正常说明98并没有超出范围，第一种是加法运算，编译器编译时并不知道他的结果超出范围了没，只有运行的时候才会出结果，所以需要强制类型转换。</p>
<p><strong>同理</strong></p>
<p>int a&#x3D;1</p>
<p>short x&#x3D;a；</p>
<p>（错误）</p>
<p>与上面同理，编译过程中，计算机只判断a是int型，int型赋给short就得需要转换，他不会知道a很小。</p>
<h3 id="多种类型运算"><a href="#多种类型运算" class="headerlink" title="多种类型运算"></a>多种类型运算</h3><p>long a&#x3D;10L</p>
<p>char c&#x3D;’a’</p>
<p>short s&#x3D;’100’</p>
<p>int i&#x3D;30</p>
<p>求和后是long型</p>
<p><strong>结论</strong>：多种数据类型做混合运算时，最终的结果类型是“最大容量”对应的类型。</p>
<p><strong>但char+short+byte混合除外</strong>，因为这个会各自转换为int再运算。</p>
<h2 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h2><p>float 4字节</p>
<p>double 8字节</p>
<p>float是单精度，double双精度</p>
<p>double更精确</p>
<p><strong>long 8字节 float 4字节 哪个容量大？？</strong></p>
<p>注意：任意一个浮点型都比整数型空间大。</p>
<p><strong>java中规定，任何一个浮点型数据默认被当做double来处理如果想让被当做float类型出行，后面加F或f</strong>，或者用强制类型转换，但可能会损失精度</p>
<h2 id="boolean型"><a href="#boolean型" class="headerlink" title="boolean型"></a>boolean型</h2><p>在java中只有true和false ，和c语言不同，不能用0和1表示。</p>
<p>一般用在逻辑判断中。</p>
<p>int a&#x3D;10</p>
<p>int b&#x3D;20</p>
<p>boolean flag&#x3D;a&lt;b  </p>
<p>输出flag就是true</p>
<h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><p><strong>跟c差不多</strong></p>
<p>&amp;有一边为false，即为false。</p>
<p>|有一边为true，即为true。</p>
<h2 id="短路"><a href="#短路" class="headerlink" title="短路"></a>短路</h2><p>&amp;和&amp;&amp;结果相同</p>
<p>但&amp;&amp;会有短路效果，&amp;&amp;左面表达式是false，决定整个式子是false了，右边就不会进行。</p>
<p>同理||也一样。</p>
<h2 id="i-i-1和i-1真的一样吗？？？"><a href="#i-i-1和i-1真的一样吗？？？" class="headerlink" title="i&#x3D;i+1和i+&#x3D;1真的一样吗？？？"></a>i&#x3D;i+1和i+&#x3D;1真的一样吗？？？</h2><p>byte x&#x3D;100； </p>
<p>x&#x3D;x+1 [会报错，1是int类型，x+1也是int类型，直接赋值给byte，会报错]</p>
<p>x+&#x3D;1 [不会报错，扩展赋值运算符，不会改变运算结果类型。]</p>
<p>x+&#x3D;1等同于：x&#x3D;（byte）（x+1）</p>
<h2 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符"></a>三目运算符</h2><p>跟c一样</p>
<h2 id="运算符（字符串拼接）"><a href="#运算符（字符串拼接）" class="headerlink" title="运算符（字符串拼接）"></a>运算符（字符串拼接）</h2><p>当+运算符两边的任意一边是字符串类型，那么这个+会进行字符串拼接操作。</p>
<p>字符串拼接完之后的结果还是一个字符串</p>
<p>加法遵循自左向右。</p>
<p><strong>例子</strong></p>
<p>在控制台输出 100+200&#x3D;300</p>
<p>int a&#x3D;100，b&#x3D;200</p>
<p>System.out.println（a+“+”+b+“&#x3D;”+c）</p>
<p><strong>字符串拼接易错题</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;5&#x27;</span>+<span class="number">2</span>  <span class="comment">//等于55</span></span><br><span class="line"> <span class="string">&quot;5&quot;</span>+<span class="number">2</span> <span class="comment">//等于52</span></span><br></pre></td></tr></table></figure>



<h2 id="如果定义字符串型变量"><a href="#如果定义字符串型变量" class="headerlink" title="如果定义字符串型变量"></a>如果定义字符串型变量</h2><p>String name&#x3D;“zhang”</p>
<h2 id="六-接收用户键盘输入（先不用理解）-退出JVM"><a href="#六-接收用户键盘输入（先不用理解）-退出JVM" class="headerlink" title="六.接收用户键盘输入（先不用理解）+退出JVM"></a>六.接收用户键盘输入（先不用理解）+退出JVM</h2><p>java.util.Scanner s&#x3D;new java.util.Scanner（System.in）；</p>
<p>int i&#x3D;s.nextInt（）； [输入整型]</p>
<p>String str&#x3D;s.next();   [输入字符串]</p>
<p>double score&#x3D;s.nextDouble（） [输入小数]</p>
<p>System.exit（0）； 退出jvm</p>
<h2 id="七-if-三目-Switch"><a href="#七-if-三目-Switch" class="headerlink" title="七.if 三目 Switch"></a>七.if 三目 Switch</h2><p>跟c差不多。</p>
<h4 id="1-Switch"><a href="#1-Switch" class="headerlink" title="1.Switch"></a>1.Switch</h4><p>Switch（值）</p>
<p>值支持int类型以及String类型。</p>
<p>byte short char也可以使用在Switch里。因为可自动类型转换</p>
<p>但是long 型的不行</p>
<p>case 1：</p>
<p>……. ；</p>
<p>break；</p>
<p>case 2 ：</p>
<p>…….；</p>
<p>break；</p>
<p>想合并就</p>
<p>case1： case2：</p>
<p>……..；</p>
<p>break；</p>
<h2 id="八-转向语句"><a href="#八-转向语句" class="headerlink" title="八.转向语句"></a>八.转向语句</h2><p><strong>break的一种特殊用法</strong></p>
<p> a：for（）{</p>
<p>​    b：for（）{</p>
<p>​           i f(){</p>
<p>​             break a；</p>
<p>​             }</p>
<p>​     }</p>
<p>}</p>
<p>这样可以选择终止哪个循环。</p>
<h2 id="九-方法"><a href="#九-方法" class="headerlink" title="九.方法"></a>九.方法</h2><p>跟c语言函数类似。</p>
<p><strong>语法机制</strong></p>
<p>[修饰符列表] 返回值类型 方法名（形式参数列表）{</p>
<p>​       方法体；</p>
<p>}</p>
<p>注意： []里的不是必须的。</p>
<p>修饰符列表目前写成public static ，后续就知道怎么写了。</p>
<h4 id="1-返回值类型"><a href="#1-返回值类型" class="headerlink" title="1.返回值类型"></a>1.返回值类型</h4><p>所有基本数据类型和引用数据类型。</p>
<h4 id="2-返回值类型不是void，就必须有return"><a href="#2-返回值类型不是void，就必须有return" class="headerlink" title="2.返回值类型不是void，就必须有return"></a>2.返回值类型不是void，就必须有return</h4><h4 id="3-类名省略"><a href="#3-类名省略" class="headerlink" title="3.类名省略"></a>3.类名省略</h4><p>当a方法调用b方法时，a和b方法都在同一个类中，“类名”可以省略。如果不在同一个类中不能省略。</p>
<p>意思是a，b在同一个类时，引用直接 方法名（）就行。</p>
<p>不在同一类，引用得  类名.方法名（）</p>
<h4 id="4-return-用来终止离他最近的一个方法。"><a href="#4-return-用来终止离他最近的一个方法。" class="headerlink" title="4.return 用来终止离他最近的一个方法。"></a>4.return 用来终止离他最近的一个方法。</h4><h4 id="5-缺少返回语句"><a href="#5-缺少返回语句" class="headerlink" title="5.缺少返回语句"></a>5.缺少返回语句</h4><p>public static int m（）{</p>
<p>   boolean flag &#x3D;true；</p>
<p>   if(flag){</p>
<p>​      return 1；</p>
<p>​     }</p>
<p>}</p>
<p>上述程序会报错</p>
<p><strong>编译器不会知道flag是true型，他只知道如果flag是false，则没有返回值，而int方法必须有返回值</strong>、</p>
<h4 id="6-JVM（java虚拟机）内存结构"><a href="#6-JVM（java虚拟机）内存结构" class="headerlink" title="6.JVM（java虚拟机）内存结构"></a>6.JVM（java虚拟机）内存结构</h4><p>JVM中主要的三块内存空间：</p>
<p> <strong>栈、堆、方法区</strong></p>
<p>栈：在方法被调用时候，该方法需要的内存空间在栈中分配。</p>
<p>堆：以后讲。</p>
<p>方法区：类加载器classloader，将硬盘上的XXX.class字节码文件装载到JVM的时候，会将字节码文件存放到方法区当中。也就是说方法区存储的是代码片段。</p>
<p>因为类需要加载，所以方法区当中最先有数据。</p>
<h4 id="7-方法执行过程中内存变化"><a href="#7-方法执行过程中内存变化" class="headerlink" title="7.方法执行过程中内存变化"></a>7.方法执行过程中内存变化</h4><p>1.方法区最先有数据：方法区中放代码片段，存放class字节码。</p>
<p>2.方法只有在调用的时候才会在栈中分配空间，并且调用时就是压栈。</p>
<p>3.方法执行结束后，该方法所需要的空间就会释放，此时发生弹栈动作。</p>
<p>4.栈中存储什么？ 方法执行过程中需要的内存，以及栈中会存储方法的局部变量。</p>
<p><img src="E:\study\后端\java\image\1.jpg" alt="1"></p>
<p><strong>类加载器将字节码文件放到方法区里，然后开始执行，最初执行main方法，main方法的栈帧先在栈区有空间，然后调用m1，m1也在栈区里。最后m3、m2、m1、main依次顺序弹栈</strong></p>
<p><img src="E:\study\后端\java\image\2.jpg" alt="2"></p>
<h4 id="8-方法重载"><a href="#8-方法重载" class="headerlink" title="8.方法重载"></a>8.方法重载</h4><p>[想求int的和，小数的和，long型的和需要创三个方法]</p>
<p>如果不使用方法重载，有什么缺点？？？</p>
<p>1.代码不美观</p>
<p>2.程序员记忆方法名很累</p>
<p> <strong>方法重载</strong></p>
<p>功能相似的方法给一样的方法名。</p>
<p>比如int求和，long求和，double求和。</p>
<p>都</p>
<p>public static int sum(int a,int b)</p>
<p>public static long sum(long a,long b)</p>
<p>public static double sum(double a,double b)</p>
<p><strong>调用的时候都用sum就行，编译器会根据你给参数的数据类型判断去哪里执行。</strong></p>
<p><strong>重载</strong></p>
<p>{</p>
<p>在一个类中</p>
<p>方法名相同</p>
<p>参数列表不同 </p>
<p>   1.个数不同</p>
<ol start="2">
<li>类型不同</li>
<li>顺序不同</li>
</ol>
<p>}</p>
<h4 id="9-函数递归"><a href="#9-函数递归" class="headerlink" title="9.函数递归"></a>9.函数递归</h4><p>跟c语言递归一个道理</p>
<p>递归可能会导致栈空间不足。所以必须有结束条件。</p>
<p>但即使有结束条件，也可能会栈空间不足。(有可能递归太深)</p>
<p>可以用java-X命令查询，如何更改栈空间之类的操作。</p>
<p><strong>n的阶乘</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span>&#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">          <span class="type">int</span> a=sum(<span class="number">4</span>);</span><br><span class="line">          s.p(a);</span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> n*sum(n-<span class="number">1</span>);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="十-面向对象"><a href="#十-面向对象" class="headerlink" title="十.面向对象"></a>十.面向对象</h2><h3 id="1-面向对象和面向过程区别"><a href="#1-面向对象和面向过程区别" class="headerlink" title="1.面向对象和面向过程区别"></a>1.面向对象和面向过程区别</h3><p><strong>面向过程：c语言</strong></p>
<p><strong>注重的是实现这个功能的步骤</strong></p>
<p>面向过程也注重实现功能的因果关系。</p>
<p>面向过程中没有对象的概念，只是实现这个功能的步骤。</p>
<p><strong>缺点</strong></p>
<p>面向过程主要是一步一步的因果关系，其中A步骤因果关系到B步骤，A和B联合起来形成一个子模块，子模块和子模块之间又因为因果关系结合在一起，假设其中一个因果关系出现问题（错误），此时整个系统的运转都会出现问题。（代码和代码粘合度高，扩展力差）</p>
<p><strong>优点</strong></p>
<p>小型项目，直接干活，编写因果关系，从而实现功能。</p>
<p><strong>面向对象</strong></p>
<p>  采用面向对象的方式进行开发，更符合人类的思维方式。</p>
<p><strong>面向对象就是将现实世界分割成不同的单元，然后每一个单元都实现成对象，然后驱动一下，让各个对象之间写作起来形成一个系统</strong></p>
<p>​                <strong>例子</strong></p>
<p><strong>对象</strong>”张三“</p>
<p><strong>对象</strong>“香烟”</p>
<p><strong>对象</strong>“打火机”</p>
<p>然后将上面对象组合在一起，就可以模拟一个人的抽烟场景。</p>
<p>其中“张三”还可以换成“李四”。</p>
<p>​                             <strong>扩展力强</strong></p>
<h3 id="2-OOA-OOD-OOP"><a href="#2-OOA-OOD-OOP" class="headerlink" title="2. OOA OOD OOP"></a>2. OOA OOD OOP</h3><p>OOA: 面向对象分析</p>
<p>OOD：面向对象设计</p>
<p>OOP：面向对象编程</p>
<p>上述为实现一个软件的过程。</p>
<h3 id="3-面向对象三大特征（了解，后面讲）"><a href="#3-面向对象三大特征（了解，后面讲）" class="headerlink" title="3.面向对象三大特征（了解，后面讲）"></a>3.面向对象三大特征（了解，后面讲）</h3><p>封装</p>
<p>继承</p>
<p>多态</p>
<p>任何一个面向对象的编程语言都包括这三个特征。</p>
<h3 id="4-类和对象的概念"><a href="#4-类和对象的概念" class="headerlink" title="4.类和对象的概念"></a>4.类和对象的概念</h3><p>什么是类？</p>
<p>​       类实际上在现实世界中是不存在的，是一个抽象的概念，是一个模板。是我们人类大脑进行思考，总结，抽象的一个结果。</p>
<p>什么是对象？</p>
<p>​       对象是实际存在的个体。</p>
<p><strong>例如</strong></p>
<p>  赵露思是一个对象</p>
<p>  鹿晗是一个对象</p>
<p>  刘德华是一个对象</p>
<p>  这三个对象都属于“明星”这个类。</p>
<p>在java中，要想得到“对象”，必须先定义“类”，“对象”是通过“类”</p>
<p>这个模板创造出来的、</p>
<p>   类就是一个模板：类中描述的是所有对象的共同特征信息，对象是通过类创建出的个体。</p>
<p><img src="E:\study\后端\java\image\类和对象的理解.jpg" alt="类和对象的理解"></p>
<p><strong>类&#x3D;属性+方法</strong></p>
<p>属性来源于状态，方法来源于动作。</p>
<p>public class 明星类{</p>
<p>  &#x2F;&#x2F;属性–&gt;状态，多见于名词。</p>
<p>  名字属性：</p>
<p>  身高属性：</p>
<p>   &#x2F;&#x2F;方法–&gt;动作，多见于动词。</p>
<p>   打篮球方法（）{}</p>
<p>   study方法（）{}</p>
<p>}</p>
<h3 id="5-java程序员是一个转换的桥梁"><a href="#5-java程序员是一个转换的桥梁" class="headerlink" title="5.java程序员是一个转换的桥梁"></a>5.java程序员是一个转换的桥梁</h3><p>将现实生活中的一些事物转换。</p>
<p>具备 <strong>观察+抽象</strong>能力，观察现实世界中对象1和对象2的共同特征，然后在java程序中使用“类”来描述这些共同特征，然后通过“类”实例化“对象”，让对象之间互相协作起来形成系统，模拟现实世界。</p>
<h3 id="6-类的定义"><a href="#6-类的定义" class="headerlink" title="6.类的定义"></a>6.类的定义</h3><h4 id="6-1-怎么定义一个类？"><a href="#6-1-怎么定义一个类？" class="headerlink" title="6.1 怎么定义一个类？"></a>6.1 怎么定义一个类？</h4><p>  [修饰符列表] class 类名{</p>
<p>​     &#x2F;&#x2F;类体&#x3D;属性+方法</p>
<p>​     &#x2F;&#x2F;属性在代码上以“变量”的形式存在（描述状态）</p>
<p>​     &#x2F;&#x2F;方法描述动作&#x2F;行为</p>
<p> }</p>
<p><strong>属性其实就是成员变量</strong></p>
<h4 id="6-2对象的创建"><a href="#6-2对象的创建" class="headerlink" title="6.2对象的创建"></a>6.2对象的创建</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XueSheng</span>&#123;</span><br><span class="line">    <span class="type">int</span> xuehao;</span><br><span class="line">    <span class="type">int</span> nianling;</span><br><span class="line">    <span class="type">char</span> xingbie;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后在其他地方</p>
<p> new XueSheng（）；就行。</p>
<p>但是你创建了想使用的话，必须接收一下他。</p>
<p>接收东西，比如 int b&#x3D;10；</p>
<p><strong>变量类型+变量名&#x3D;</strong></p>
<p>因此，创建对象是：  XueSheng s1&#x3D;new XueSheng （）；</p>
<p><strong>类就是引用数据类型</strong></p>
<h4 id="6-3-编译过程"><a href="#6-3-编译过程" class="headerlink" title="6.3 编译过程"></a>6.3 编译过程</h4><p>按理来说，需要先编译那个类的文件，再编译使用类去弄出来的对象的文件。</p>
<p><strong>但是</strong></p>
<p>可以直接编译对象那个文件，这样类文件会自动编译。</p>
<h4 id="6-4创建对象对应的jvm内存结构"><a href="#6-4创建对象对应的jvm内存结构" class="headerlink" title="6.4创建对象对应的jvm内存结构"></a>6.4创建对象对应的jvm内存结构</h4><p><img src="E:\study\后端\java\image\创建对象的jvm示意图.jpg" alt="创建对象的jvm示意图"></p>
<p>之前说，变量必须声明，赋值后才能使用。</p>
<p><strong>但成员变量，没有赋值时，系统默认赋值</strong></p>
<table>
<thead>
<tr>
<th>类型</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>0</td>
</tr>
<tr>
<td>short</td>
<td>0</td>
</tr>
<tr>
<td>int</td>
<td>0</td>
</tr>
<tr>
<td>long</td>
<td>0L</td>
</tr>
<tr>
<td>float</td>
<td>0.0F</td>
</tr>
<tr>
<td>double</td>
<td>0.0</td>
</tr>
<tr>
<td>boolean</td>
<td>false</td>
</tr>
<tr>
<td>char</td>
<td>\u0000</td>
</tr>
<tr>
<td>引用数据类型</td>
<td>null</td>
</tr>
</tbody></table>
<p><strong>实例变量</strong></p>
<p>对象又被称为实例。</p>
<p>实例变量实际上就是：对象级别的变量。</p>
<p>public class 明星类{</p>
<p>  double height；</p>
<p>}</p>
<p>身高这个属性所有明星对象都有，但是每一个对象都有“自己的身高值”。假设创建10个明星对象，height变量应该有10份。</p>
<p>所以这种变量被称为对象级别的变量，属于实例变量。</p>
<p><strong>因此，不能通过类名直接访问实例变量</strong>，必须创键对象。</p>
<p><strong>对象和引用</strong></p>
<p>对象是通过new出来的，在堆内存中存储。</p>
<p>引用是：但凡是变量，并且该变量中保存了内存地址指向了堆内存当中的对象的。</p>
<p><strong>怎么访问实例变量</strong></p>
<p>语法：引用.实例变量名</p>
<p><strong>实例变量都是默认值，如何修改</strong></p>
<p>直接通过&#x3D;赋值进行修改。</p>
<h4 id="6-5-内存图"><a href="#6-5-内存图" class="headerlink" title="6.5 内存图"></a>6.5 内存图</h4><p>内存图上不要体现出代码，主要体现数据</p>
<p>画内存图是对java运行机制的一种理解，有助于以后复杂程序出错的调试。</p>
<p>画图时，应有先后顺序。  </p>
<h4 id="6-6-引用一定是局部变量吗？"><a href="#6-6-引用一定是局部变量吗？" class="headerlink" title="6.6 引用一定是局部变量吗？"></a>6.6 引用一定是局部变量吗？</h4><p>不一定</p>
<p>new的某个对象里面也可以有一个引用指向其他对象。</p>
<p>就类似c语言结构体里面还有一个结构体的感觉。</p>
<p><strong>通过引用的目的是访问对象里面的数据。</strong>	</p>
<h4 id="6-7-属性是引用类型怎么访问。"><a href="#6-7-属性是引用类型怎么访问。" class="headerlink" title="6.7 属性是引用类型怎么访问。"></a>6.7 属性是引用类型怎么访问。</h4><p>一个例子</p>
<p>如何从test类一直访问到i的值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span>&#123;</span><br><span class="line">    A o1;</span><br><span class="line">    </span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] arge)</span> &#123;</span><br><span class="line">      <span class="type">D</span> <span class="variable">d</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">D</span>();</span><br><span class="line">      <span class="type">C</span> <span class="variable">c</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">C</span>();</span><br><span class="line">      <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">      <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">     </span><br><span class="line">      <span class="type">test</span> <span class="variable">t</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">test</span>();</span><br><span class="line">  </span><br><span class="line">       </span><br><span class="line">       c.o4=d;</span><br><span class="line">       b.o3=c;</span><br><span class="line">       a.o2=b;</span><br><span class="line">       t.o1=a;</span><br><span class="line">       System.out.println(t.o1.o2.o3.o4.i);</span><br><span class="line">   &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">   B o2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line">   C o3;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>&#123;</span><br><span class="line">   D o4;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>&#123;</span><br><span class="line">   <span class="type">int</span> i=<span class="number">100</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-8空指针异常（NullPointerException）"><a href="#6-8空指针异常（NullPointerException）" class="headerlink" title="6.8空指针异常（NullPointerException）"></a>6.8空指针异常（NullPointerException）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NullPointertest</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="title function_">void</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        customer c=<span class="keyword">new</span> <span class="title class_">customer</span>();</span><br><span class="line">        System.out.println(c.id);<span class="comment">//0</span></span><br><span class="line">        <span class="comment">//若c为null会怎样？</span></span><br><span class="line">        c=<span class="literal">null</span>;</span><br><span class="line">        System.out.println(c.id);<span class="comment">//NullPointerException</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="E:\study\后端\java\image\空指针异常.jpg" alt="空指针异常"></p>
<p><strong>java中的垃圾回收器 GC</strong></p>
<p>​      在java语言中主要针对的是堆内存，在一个java对象没有任何引用指向该对象的时候，GC会考虑将该垃圾数据释放回收掉。</p>
<p><strong>6.7中的代码</strong></p>
<p>如果</p>
<p>​       c.o4&#x3D;d;<br>​       b.o3&#x3D;c;<br>​       a.o2&#x3D;b;<br>​       t.o1&#x3D;a;</p>
<p>这一段不写，也会出现空指针异常。</p>
<p><strong>因为o1 o2 o3都是空的，无法点点点，必须把new来的对象赋给他们。</strong></p>
<p><strong>空指针异常的前提条件</strong></p>
<p>“空引用”访问实例相关【对象相关】的数据时，都会出现空指针异常</p>
<h4 id="6-9方法调用时参数的传递问题"><a href="#6-9方法调用时参数的传递问题" class="headerlink" title="6.9方法调用时参数的传递问题"></a>6.9方法调用时参数的传递问题</h4><p>参数传递只是将值复制一份传递下去。</p>
<p>跟c语言一样，变量有作用域，在某个方法里i++了，但出了这个方法i还是原来的值。</p>
<p>但是！ 参数如果是对象，传递的是地址，比如传递一个p，p点什么什么不管在哪个方法里都是一样的，因为传递前后地址一样。（跟c语言指针差不多）</p>
<h3 id="7-构造方法"><a href="#7-构造方法" class="headerlink" title="7.构造方法"></a>7.构造方法</h3><h4 id="7-1什么是构造方法，有什么用？"><a href="#7-1什么是构造方法，有什么用？" class="headerlink" title="7.1什么是构造方法，有什么用？"></a>7.1什么是构造方法，有什么用？</h4><p> 构造方法是一个比较特殊的方法，通过构造方法可以完成对象的创建，以及实例变量的初始化。换句话说：构造方法是用来创建对象，并且同时给对象的属性赋值。（注意：实例变量没有手动赋值的时候，系统会赋默认值。）</p>
<h4 id="7-2-当一个类没有提供构造方法时，系统会默认提供一个无参数的构造方法（这个构造方法被称为缺省构造器）。但是当一个类中提供了方法时，系统就不会再提供那一个无参数的构造方法了，这时你想调用无参的这个方法，就会报错"><a href="#7-2-当一个类没有提供构造方法时，系统会默认提供一个无参数的构造方法（这个构造方法被称为缺省构造器）。但是当一个类中提供了方法时，系统就不会再提供那一个无参数的构造方法了，这时你想调用无参的这个方法，就会报错" class="headerlink" title="7.2 当一个类没有提供构造方法时，系统会默认提供一个无参数的构造方法（这个构造方法被称为缺省构造器）。但是当一个类中提供了方法时，系统就不会再提供那一个无参数的构造方法了，这时你想调用无参的这个方法，就会报错"></a>7.2 当一个类没有提供构造方法时，系统会默认提供一个无参数的构造方法（这个构造方法被称为缺省构造器）。但是当一个类中提供了方法时，系统就不会再提供那一个无参数的构造方法了，这时你想调用无参的这个方法，就会报错</h4><h4 id="7-3构造方法如何调用？"><a href="#7-3构造方法如何调用？" class="headerlink" title="7.3构造方法如何调用？"></a>7.3构造方法如何调用？</h4><p>使用<strong>new运算符</strong>来调用构造方法</p>
<p><strong>new+方法名+（实参）</strong></p>
<h4 id="7-4-构造方法的语法结构是？"><a href="#7-4-构造方法的语法结构是？" class="headerlink" title="7.4 构造方法的语法结构是？"></a>7.4 构造方法的语法结构是？</h4><p> [修饰符列表] 构造方法名 （形式参数列表）{</p>
<p>   构造方法体；</p>
<p>通常在构造方法体当中给属性赋值，完成属性的初始化。</p>
<p>}</p>
<p>修饰符列表目前统一写 public，千万别写public static。</p>
<p>构造方法名和类名必须一致。</p>
<p>构造方法不需要指定返回值类型，也不能写void。</p>
<p>  <strong>普通方法语法结构</strong></p>
<p>[修饰符列表] 返回值类型 方法名 （形式参数列表）{</p>
<p>   方法体；</p>
<p>}</p>
<p> <strong>构造方法支持重载</strong>，因为构造方法名必须跟类名相同，所以当参数不同，就重载了。</p>
<h4 id="7-5-实例变量初始化啥时候？"><a href="#7-5-实例变量初始化啥时候？" class="headerlink" title="7.5 实例变量初始化啥时候？"></a>7.5 实例变量初始化啥时候？</h4><p>创键了对象后。</p>
<h2 id="十一-封装"><a href="#十一-封装" class="headerlink" title="十一.封装"></a>十一.封装</h2><h3 id="1-面向对象的三大特征"><a href="#1-面向对象的三大特征" class="headerlink" title="1.面向对象的三大特征"></a>1.面向对象的三大特征</h3><p>封装</p>
<p>继承</p>
<p>多态</p>
<h3 id="2-面向对象的首要特征：封装"><a href="#2-面向对象的首要特征：封装" class="headerlink" title="2.面向对象的首要特征：封装"></a>2.面向对象的首要特征：封装</h3><h4 id="2-1-什么是封装？"><a href="#2-1-什么是封装？" class="headerlink" title="2.1 什么是封装？"></a>2.1 什么是封装？</h4><p>现实生活中例如手机，电视机。外部有一个坚硬的壳，保护内部部件安全。</p>
<p>对于使用者来着，看不见内部复杂结果，我们也不需要看见，只需要操作外部的几个按钮就行。</p>
<h4 id="2-2-封装有什么用？"><a href="#2-2-封装有什么用？" class="headerlink" title="2.2 封装有什么用？"></a>2.2 封装有什么用？</h4><h5 id="1-保证内部结构安全"><a href="#1-保证内部结构安全" class="headerlink" title="1.保证内部结构安全"></a>1.保证内部结构安全</h5><h5 id="2-屏蔽复杂，暴露简单"><a href="#2-屏蔽复杂，暴露简单" class="headerlink" title="2.屏蔽复杂，暴露简单"></a>2.屏蔽复杂，暴露简单</h5><p><strong>在代码级别上，封装有什么用？</strong></p>
<p>  一个类体当中的数据，假设封装之后，对于代码的调用人员来说，不需要关心代码的复杂实现，只需要通过一个简单的入口就可以访问了。</p>
<p>另外，类体中安全级别较高的数据封装起来，外部人员不能随意访问，来保证数据的安全性。</p>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4><h4 id="2-3不封装有什么问题"><a href="#2-3不封装有什么问题" class="headerlink" title="2.3不封装有什么问题"></a>2.3不封装有什么问题</h4><p>例如person对象里的属性age，如果不封装，年龄可在外部任意更改，哪怕给年龄负数，也不会报错，不符合业务要求。</p>
<h4 id="2-4尝试封装一下"><a href="#2-4尝试封装一下" class="headerlink" title="2.4尝试封装一下"></a>2.4尝试封装一下</h4><p>不再对外暴露复杂的数据，封装起来。</p>
<p>对外只提供简单的操作入口。</p>
<p>优点：第一数据安全了，第二调用者也方便了。</p>
<h4 id="2-5怎么进行封装？"><a href="#2-5怎么进行封装？" class="headerlink" title="2.5怎么进行封装？"></a>2.5怎么进行封装？</h4><p>第一步：属性私有化（使用private关键字进行修饰）<strong>私有的可以在本类中访问</strong></p>
<p>第二步：对外提供简单的操作入口。（set+get）；</p>
<p><strong>private</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//被这个关键词修饰以后，该数据只能在本类中访问。</span></span><br><span class="line">    <span class="comment">//出了这个类，age属性就无法访问了，私有的。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age；</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后new对象后，想输入和修改这个对象的age值，编译会报错说age在Person中被private控制。</p>
<p>age彻底在外部不能访问了，但是这有点太安全了。age不能访问，这个程序就意义不大了。</p>
<p><strong>因此还需要对外提供简单的入口，外部程序只能通过调用以下的代码来完成访问。</strong></p>
<p>思考：你应该对外提供几个访问入口。</p>
<p>思考：这些操作入口是否应该是方法呢。</p>
<p>写一个方法专门来完成读（get）</p>
<p>写一个方法专门来完成写（set）</p>
<h5 id="中间引入一个实例方法"><a href="#中间引入一个实例方法" class="headerlink" title="中间引入一个实例方法"></a>中间引入一个实例方法</h5><h6 id="带有static的方法"><a href="#带有static的方法" class="headerlink" title="带有static的方法"></a>带有static的方法</h6><h6 id="不带static的方法"><a href="#不带static的方法" class="headerlink" title="不带static的方法"></a>不带static的方法</h6><p>(后面会讲为什么)</p>
<h6 id="分别怎么调用？"><a href="#分别怎么调用？" class="headerlink" title="分别怎么调用？"></a>分别怎么调用？</h6><p><strong>带static通过类名.的方式访问</strong></p>
<p><strong>不带static的被称为实例方法</strong></p>
<p>对象被称为实例。</p>
<p>实例相关的都需要先new对象，通过引用.的方式去访问。比如实例方法。</p>
<p> <strong>实例方法跟构造方法一样，也会出现空指针异常</strong></p>
<p><strong>空指针异常导致的根本原因是？</strong></p>
<p>空引用访问“实例相关的数据”，会出现空指针异常。</p>
<p>实例相关的包括：实例变量，实例方法。</p>
<p>接着2.5<strong>继续</strong></p>
<p>get和set应该带有static还是不该？</p>
<p>不应该，改年龄和读年龄都是操作一个对象的年龄。</p>
<p><strong>封装第二步（第一步是private）：对外提供公开的set方法和get方法作为操作入口</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//被这个关键词修饰以后，该数据只能在本类中访问。</span></span><br><span class="line">    <span class="comment">//出了这个类，age属性就无法访问了，私有的。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age；</span><br><span class="line">     </span><br><span class="line">       </span><br><span class="line">        </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> nianling)</span>&#123;</span><br><span class="line">        age=nianling;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>java开发规范中有要求，set方法和get方法的格式</strong></p>
<p>​        <strong>get</strong></p>
<p>​          public 返回值类型 get+属性名首字母大写（无参）{</p>
<p>​                return xxx；</p>
<p>}</p>
<p>​          <strong>set</strong></p>
<p>​            public void set+属性名首字母大写（有一个参数）{</p>
<p>​                   xxx&#x3D;参数；</p>
<p>}  </p>
<h1 id="-1"><a href="#-1" class="headerlink" title=""></a></h1><h2 id="十二-static"><a href="#十二-static" class="headerlink" title="十二 static"></a>十二 static</h2><h3 id="1-static"><a href="#1-static" class="headerlink" title="1.static"></a>1.static</h3><p>static翻译为“静态的”</p>
<p>  所有static关键字修饰的都是类相关的，类级别的。</p>
<p> 所有static修饰的，都是采用类名.的方式访问</p>
<p>  static修饰的方法：静态方法。</p>
<p><strong>变量分为局部变量和成员变量</strong></p>
<p><strong>成员变量又分为静态变量和实例变量</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">vartest</span>&#123;</span><br><span class="line">    <span class="comment">//实例的都是和对象相关，访问时用引用.访问。需要先new，可能出现空指针异常</span></span><br><span class="line">    <span class="type">int</span> i; <span class="comment">//实例变量</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//实例方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//以下静态的，都是类相关的，访问采用类名.的方式。不需要new，没有空指针异常的发生。</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> k;  <span class="comment">//静态变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//静态方法</span></span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-什么时候用静态的，什么时候用实例的。"><a href="#2-什么时候用静态的，什么时候用实例的。" class="headerlink" title="2.什么时候用静态的，什么时候用实例的。"></a>2.什么时候用静态的，什么时候用实例的。</h3><p>一个对象一份的是实例变量，所有对象一份的是静态变量。</p>
<p><strong>中国人的例子</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">staticTest</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] arge)</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Chinese</span>&#123;</span><br><span class="line">        String idcard;<span class="comment">//idcard每个人都不一样，所以不加static，是实例变量。</span></span><br><span class="line">        String name;<span class="comment">//name也不一样</span></span><br><span class="line">        String country;<span class="comment">//对于中国人这个类来说，country都一样，先假设他是实例，画下面内存图，看有什么问题。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="E:\study\后端\java\image\什么时候用静态变量.jpg" alt="什么时候用静态变量"></p>
<p>由图能看出，country每个人都一样，但因为是实例变量，所以每次都new出country，浪费了不必要的空间。</p>
<p><strong>因此给country加static</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">staticTest</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] arge)</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Chinese</span>&#123;</span><br><span class="line">        String idcard;<span class="comment">//idcard每个人都不一样，所以不加static，是实例变量。</span></span><br><span class="line">        String name;<span class="comment">//name也不一样</span></span><br><span class="line">        <span class="keyword">static</span> String country;<span class="comment">//对于中国人这个类来说，country都一样.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>static String country  是成员变量，会给默认值，但他不像实例变量，实例变量是在new对象时给默认值</p>
<p><strong>静态变量在类加载时初始化，不需要new对象，静态变量存储在方法区。</strong></p>
<p>在方法区内加载chinese类时，发现chinese类中有一个静态变量，此时会给该静态变量初始化。</p>
<p>此时，要访问country，静态变量，所以用 chinese.country访问。</p>
<p>如果你想 chinese.idcard 则会报错  <strong>无法从静态上下文中引用非静态变量idcard</strong>  意思是chinese是class，是静态的，idcard是实例变量，是非静态的，无法这么引用。</p>
<p><strong>栈—局部变量</strong>   <strong>堆—实例变量（对象级别）</strong>  <strong>方法区—静态变量（类级别）</strong></p>
<h3 id="3-空引用访问静态变量"><a href="#3-空引用访问静态变量" class="headerlink" title="3.空引用访问静态变量"></a>3.空引用访问静态变量</h3><p><strong>实例一定需要引用.访问</strong></p>
<p><strong>静态的建议使用类名.访问</strong>（引用.也行）（不建议）。</p>
<p><strong>同时</strong>，若用空引用访问静态变量，</p>
<p> c1&#x3D;null    c1.country</p>
<p>不会出现空指针异常，因为静态变量不需要对象的存在。</p>
<p><strong>因此</strong>，只有在“空引用”访问“实例”相关的，才会出现空指针异常。</p>
<h3 id="4-关于实例方法的调用"><a href="#4-关于实例方法的调用" class="headerlink" title="4.关于实例方法的调用"></a>4.关于实例方法的调用</h3><p>静态方法 使用类名.，也可以引用.，但不建议</p>
<p><strong>实例方法</strong> new对象，用引用.来访问。</p>
<p>什么时候定义为实例方法？什么时候定义为静态方法？</p>
<p><strong>方法一般都是描述了一个行为，如果说该行为必须由对象去触发，就定义为实例方法</strong></p>
<p>比如之前的set和get方法（年龄），他是为了让外界查找年龄或者更改年龄，而年龄是每个对象不一样，所以要定义为实例方法。</p>
<p><strong>如果某个方法体执行过程中访问了实例变量，那这个方法必须定义为实例方法</strong></p>
<p><strong>开发中，大部分情况下，如果是工具类的话，工具类中的方法一般都是静态的。</strong></p>
<p>工具类就是为了方便开发的一些类。直接类名.去访问，比较方便。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例子</span></span><br><span class="line"><span class="comment">//打印名字</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printName1</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printName2</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(name);   <span class="comment">//name是一个实例变量，在方法体内访问实例变量，那方法必须是实例方法，不能是static</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-静态代码块"><a href="#5-静态代码块" class="headerlink" title="5.静态代码块"></a>5.静态代码块</h3><h4 id="5-1使用static可以定义静态代码块"><a href="#5-1使用static可以定义静态代码块" class="headerlink" title="5.1使用static可以定义静态代码块"></a>5.1使用static可以定义静态代码块</h4><h4 id="5-2什么是静态代码块？"><a href="#5-2什么是静态代码块？" class="headerlink" title="5.2什么是静态代码块？"></a>5.2什么是静态代码块？</h4> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">    java语句</span><br><span class="line">     java语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-3static静态代码块什么时候执行呢？"><a href="#5-3static静态代码块什么时候执行呢？" class="headerlink" title="5.3static静态代码块什么时候执行呢？"></a>5.3static静态代码块什么时候执行呢？</h4><p>类加载时执行，并且只执行一次。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">    System.out.println(A);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(hello);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">    System.out.println(B);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出是  A  B   hello</p>
<p><strong>因为静态代码块是类加载时执行的</strong>，main方法时在栈里执行，先类加载完，才会让main方法压栈，<strong>才执行main</strong>里的输出。</p>
<h4 id="5-4静态代码块有什么用？"><a href="#5-4静态代码块有什么用？" class="headerlink" title="5.4静态代码块有什么用？"></a>5.4静态代码块有什么用？</h4><p>为java程序员准备的一个特殊时机，时间点。</p>
<h4 id="5-5-先后顺序"><a href="#5-5-先后顺序" class="headerlink" title="5.5 先后顺序"></a>5.5 先后顺序</h4><p>静态代码块和静态变量都在类加载的时候执行，时间相同，只能看代码先后顺序判断谁先谁后。</p>
<p>静态代码块不能访问实例变量，因为实例变量是在new对象时才有的。</p>
<h3 id="6-实例语句块"><a href="#6-实例语句块" class="headerlink" title="6.实例语句块"></a>6.实例语句块</h3><h4 id="6-1实力语句块语法"><a href="#6-1实力语句块语法" class="headerlink" title="6.1实力语句块语法"></a>6.1实力语句块语法</h4><p>直接一个{}</p>
<h4 id="6-2实例语句块不是在类加载时执行"><a href="#6-2实例语句块不是在类加载时执行" class="headerlink" title="6.2实例语句块不是在类加载时执行"></a>6.2实例语句块不是在类加载时执行</h4><h4 id="6-3实例语句块在构造方法执行之前执行。"><a href="#6-3实例语句块在构造方法执行之前执行。" class="headerlink" title="6.3实例语句块在构造方法执行之前执行。"></a>6.3实例语句块在构造方法执行之前执行。</h4><p>叫做对象构建时机。</p>
<h4 id="6-4实例语句块有什么用"><a href="#6-4实例语句块有什么用" class="headerlink" title="6.4实例语句块有什么用"></a>6.4实例语句块有什么用</h4><p>比如你有很多的构造方法，但他们的前几句代码都一样，你就可以写到实例代码块里，不管调哪个构造方法，都会先进行实例语句块。</p>
<h2 id="十三-this"><a href="#十三-this" class="headerlink" title="十三.this"></a>十三.this</h2><p><img src="E:\study\后端\java\image\this内存图.jpg" alt="this内存图"></p>
<p>1.this是一个关键字，全部小写、</p>
<p>2.this是什么？</p>
<p>一个对象一个this。</p>
<p>this是一个变量，是一个引用。this保存的当前对象的内存地址，指向自身。</p>
<p>所以this代表的就是当前对象，this存储在堆内存当中对象的内部。</p>
<h3 id="1-this的应用"><a href="#1-this的应用" class="headerlink" title="1.this的应用"></a>1.this的应用</h3><p>this只能使用在实例方法中。谁调用这个实例方法，this就是谁。所以this代表的是：当前对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] arge)</span>&#123;</span><br><span class="line">    user s1=<span class="keyword">new</span> <span class="title class_">user</span>(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    user s2=<span class="keyword">new</span> <span class="title class_">user</span>(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">user</span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">public</span> user&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">user</span><span class="params">(String s)</span>&#123;</span><br><span class="line">        name=s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> voud shopping&#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>.name+<span class="string">&quot;正在购物！&quot;</span>)</span><br><span class="line">            <span class="comment">//为什么不能写c1.name？ </span></span><br><span class="line">            <span class="comment">//c1是在main方法中定义的，是局部变量，去了别的方法不能用，但想调用name这种实例变量，必须“引用.”，所以产生this。</span></span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>同时，更好的理解什么时候定义实例方法，什么时候定义静态方法。</p>
<p>如果方法体里有实例变量，想访问它，就是this.name，必须是实例方法里才能出现this。</p>
<p><strong>只是一般this省略了</strong></p>
<p><img src="E:\study\后端\java\image\变量存储在哪里.jpg" alt="变量存储在哪里"></p>
<h3 id="2-this什么时候不能省略？"><a href="#2-this什么时候不能省略？" class="headerlink" title="2.this什么时候不能省略？"></a>2.this什么时候不能省略？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> no;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(<span class="type">int</span> no,String name)</span>&#123;</span><br><span class="line">        <span class="comment">//int no,String name 为什么不用int i？因为代码无可读性。</span></span><br><span class="line">        <span class="built_in">this</span>.no=no;</span><br><span class="line">        <span class="built_in">this</span>.name=name;  </span><br><span class="line">        <span class="comment">//这个时候this不能省略，如果省略就是no=no，就近原则。将没有意义。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//同理 get和set方法里也不能省略。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-通过this（）在一个构造方法里调用另一个。"><a href="#3-通过this（）在一个构造方法里调用另一个。" class="headerlink" title="3.通过this（）在一个构造方法里调用另一个。"></a>3.通过this（）在一个构造方法里调用另一个。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> year;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> month;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> day;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Date</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">        代码重复</span></span><br><span class="line"><span class="comment">        this.year =1970;</span></span><br><span class="line"><span class="comment">        this.month=1;</span></span><br><span class="line"><span class="comment">        this.day=1;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="built_in">this</span>(<span class="number">1970</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Date</span><span class="params">(<span class="type">int</span> year,<span class="type">int</span> month,<span class="type">int</span> day)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.year=year;</span><br><span class="line">        <span class="built_in">this</span>.month=month;</span><br><span class="line">        <span class="built_in">this</span>.day=day;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>this()使用一个构造方法去调用当前类的另一个构造方法，是代码简洁</strong></p>
<p><strong>特别注意</strong></p>
<p>对this的调用必须是构造器中的第一个语句！！！！！！</p>
<h1 id="-2"><a href="#-2" class="headerlink" title=""></a></h1><h2 id="十四-继承extends"><a href="#十四-继承extends" class="headerlink" title="十四.继承extends"></a>十四.继承extends</h2><h3 id="1-什么是继承？"><a href="#1-什么是继承？" class="headerlink" title="1.什么是继承？"></a>1.<strong>什么是继承</strong>？</h3><p> 使用继承解决代码臃肿。</p>
<p>一个类中的全部代码（父类）在另一个类（子类）也有。</p>
<p>可继承父类所有代码，除了构造方法以外</p>
<p>父类  class one{}</p>
<p>比如子类  </p>
<p>class two{}</p>
<p>只需在子类 class two extends one{}即可</p>
<h3 id="2-作用"><a href="#2-作用" class="headerlink" title="2.作用"></a><strong>2.作用</strong></h3><p> 基本作用：代码的复用。</p>
<p>主要作用：有了继承，才有了后期的方法覆盖和多态机制、</p>
<h3 id="3-继承的相关特性"><a href="#3-继承的相关特性" class="headerlink" title="3.继承的相关特性"></a>3.继承的相关特性</h3><ol>
<li></li>
</ol>
<p>B类继承A类，则称A类为超类（superclass），父类，基类。</p>
<p>B类则称为子类（subclass），派生类，扩展类</p>
<ol start="2">
<li></li>
</ol>
<p>java中的继承只支持单继承，c++支持多继承</p>
<p>不过可以好几个类同时继承一个类。</p>
<p><strong>如果想继承好几个类</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">a</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">b</span> <span class="keyword">extends</span> <span class="title class_">a</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">c</span> <span class="keyword">extends</span> <span class="title class_">b</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样c就同时继承了a和b</p>
<p>直接继承b，间接继承a。</p>
<p>3.除构造方法外，其他都能继承。 但是私有的属性无法在子类中直接访问。</p>
<p>4.java中，所有的类默认继承object类。</p>
<p>5.继承缺点：一改父类，子类受牵连。</p>
<h3 id="4-什么时候用继承"><a href="#4-什么时候用继承" class="headerlink" title="4.什么时候用继承"></a>4.什么时候用继承</h3><p>从语文上理解，cat是animal，所以cat能继承animal</p>
<h3 id="5-object类中的toString方法"><a href="#5-object类中的toString方法" class="headerlink" title="5.object类中的toString方法"></a>5.object类中的toString方法</h3><p>每个类都会自动继承object类。</p>
<p>toString是实例方法。</p>
<p>需要先new对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">project</span>&#123;</span><br><span class="line">    project pro=<span class="keyword">new</span> <span class="title class_">project</span>();</span><br><span class="line">    System.out.println(pro.toString);</span><br><span class="line">    <span class="comment">//project@5305068a</span></span><br><span class="line">    <span class="comment">//@前面是类名，后面的可等同看做对象在堆内存当中的内存地址。</span></span><br><span class="line">    <span class="comment">//实际上的内存地址经过“哈希算法”得出的十六进制结果。</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果直接输出引用呢</span></span><br><span class="line">    System.out.println(pro);</span><br><span class="line">    <span class="comment">//project@5305068a</span></span><br><span class="line">    <span class="comment">//println方法会自动调用pro的toString（）方法。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为println会自动调用引用的toString（）方法，所以可以利用方法覆盖把toString改成自己想要的内容，然后调用时println（引用）就行，很方便、</p>
<h1 id="-3"><a href="#-3" class="headerlink" title=""></a></h1><h2 id="十五-方法的覆盖和多态"><a href="#十五-方法的覆盖和多态" class="headerlink" title="十五.方法的覆盖和多态"></a>十五.方法的覆盖和多态</h2><h3 id="1-方法覆盖override"><a href="#1-方法覆盖override" class="headerlink" title="1.方法覆盖override"></a>1.方法覆盖override</h3><p>方法覆盖，方法重写，override overwrite</p>
<h4 id="1-1什么时候方法重载overload（回顾）"><a href="#1-1什么时候方法重载overload（回顾）" class="headerlink" title="1.1什么时候方法重载overload（回顾）"></a>1.1什么时候方法重载overload（回顾）</h4><p>在一个类中，功能相似的话，建议将名字定义的一样，代码美观。</p>
<p>什么条件满足后能构成方法重载？？？？？</p>
<p> 1.在同一个类中</p>
<p>2.方法名相同</p>
<p>3.参数列表不同（个数.顺序.类型）</p>
<h4 id="1-2方法覆盖例子"><a href="#1-2方法覆盖例子" class="headerlink" title="1.2方法覆盖例子"></a>1.2方法覆盖例子</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] arge)</span>&#123;</span><br><span class="line">   cat s1=<span class="keyword">new</span> <span class="title class_">cat</span>();</span><br><span class="line">   dog s2=<span class="keyword">new</span> <span class="title class_">dog</span>();</span><br><span class="line">   s1.move();</span><br><span class="line">   s2.move();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animals</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">move</span><span class="params">()</span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;动物在行动&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">cat</span> <span class="keyword">extends</span> <span class="title class_">Animals</span>&#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">move</span><span class="params">()</span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;猫在走猫步&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">dog</span> <span class="keyword">extends</span> <span class="title class_">Animals</span>&#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">move</span><span class="params">()</span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;狗在跑步&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>继承后的某些方法不能满足业务需求，直接把方法重写一次，然后改掉里面想更改的就行。</strong></p>
<h4 id="1-3方法覆盖条件"><a href="#1-3方法覆盖条件" class="headerlink" title="1.3方法覆盖条件"></a>1.3方法覆盖条件</h4><p>1.两个类必须有继承关系</p>
<p>2.重写后的方法和原方法一切都相同（除了想更改的）。</p>
<p>3.访问权限不能更低，可以更高。   【先记住】 修饰符列表  protected（受保护的）比public低。</p>
<p>4.重写之后的方法不能比之前的方法抛出更多的异常，可以更少（这个先记住）。</p>
<h4 id="1-4注意事项"><a href="#1-4注意事项" class="headerlink" title="1.4注意事项"></a>1.4注意事项</h4><p>1.方法覆盖只是针对方法，和属性无关</p>
<p>2.私有方法无法覆盖。</p>
<p>3.构造方法不能被继承，所以构造方法也不能被覆盖</p>
<p>4.只是针对实例方法覆盖，静态方法覆盖没有意义</p>
<h3 id="2-多态的基础语法"><a href="#2-多态的基础语法" class="headerlink" title="2.多态的基础语法"></a>2.多态的基础语法</h3><p>了解多态之前，先了解</p>
<p>1.向上转型</p>
<p>子——&gt;父（自动类型转换）</p>
<p>2.向下转型</p>
<p>父——&gt;子（强制类型转换，需要加强制类型转换符）</p>
<p><strong>无论向上还是向下，两者之间必须有继承关系</strong></p>
<h4 id="1-1向上转型"><a href="#1-1向上转型" class="headerlink" title="1.1向上转型"></a>1.1向上转型</h4><p>例如之前写过的一些例子，有父类animal，子类cat和bird。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">animal s1=<span class="keyword">new</span> <span class="title class_">cat</span>();</span><br></pre></td></tr></table></figure>

<p>这样也是允许的。</p>
<p>cat is a animal。</p>
<p>父类型的引用允许指向子类型的对象。</p>
<p><strong>那么</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s1.move();<span class="comment">//输出什么呢？ 猫走猫步 </span></span><br></pre></td></tr></table></figure>

<p><strong>为什么？？？</strong></p>
<p><strong>什么是多态？</strong></p>
<p>多种形态，多种状态。</p>
<p>分析 s1.move（）；</p>
<p>  java程序分为编译阶段和运行阶段。</p>
<p> <strong>先来分析编译阶段：</strong><br>   对于编译器来说，编译器只知道a2的类型是animal，所以编译器在检查语法的时候，会去animal.class字节码文件中找move（）方法。找到之后绑定上，静态绑定成功（编译阶段静态绑定）</p>
<p><strong>运行阶段：</strong></p>
<p>  实际上在堆内存创建的java对象是cat对象，所以move的时候，真正参与move的对象是一只猫，所以运行阶段会动态执行cat对象的move（）方法。这个过程属于运行阶段绑定。（运行阶段属于动态绑定。）</p>
<p><strong>多态表示多种形态，编译的时候一种形态，运行的时候一种形态</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假如cat类里还有抓老鼠catchMouse这个方法</span></span><br><span class="line">animal s1=<span class="keyword">new</span> <span class="title class_">cat</span>();</span><br><span class="line">s1.catchMouse();<span class="comment">//可以运行吗？？？</span></span><br></pre></td></tr></table></figure>

<p>不行！！</p>
<p>因为分析要先分析编译阶段，编译时编译器认为s1是个animal，去animal字节码文件里找，找不到catchMouse方法，就报错了。</p>
<h4 id="1-2向下转型"><a href="#1-2向下转型" class="headerlink" title="1.2向下转型"></a>1.2向下转型</h4><p><strong>什么时候要向下转型？？？？</strong></p>
<p>父类中没有的，子类中特有的（猫抓老鼠）</p>
<p><strong>需要访问子类中特有的方法时，必须向下转型</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat x=(cat)s1;<span class="comment">//s1是上面代码块那个s1</span></span><br><span class="line">x.catchMouse;<span class="comment">//就可正常运行了</span></span><br><span class="line"><span class="comment">//s1是animal，将animal强制转化为cat，就可以抓老鼠了。</span></span><br></pre></td></tr></table></figure>



<p><strong>向下转型有风险吗</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">animal s2=<span class="keyword">new</span> <span class="title class_">bird</span>();</span><br><span class="line">cat x=cat(s2);</span><br><span class="line">x.catchMouse;</span><br></pre></td></tr></table></figure>

<p>这段代码</p>
<p>先分析编译阶段：</p>
<p> 没有任何问题，编译器认为s2是动物，然后转成猫，没问题。</p>
<p>运行阶段：</p>
<p>一个鸟怎么能转换成猫呢，猫和鸟没有继承关系。</p>
<p><strong>这个异常十分重要：：：</strong> <strong>java.lang.ClassCastException</strong></p>
<h4 id="1-3怎么避免ClassCastException的发生"><a href="#1-3怎么避免ClassCastException的发生" class="headerlink" title="1.3怎么避免ClassCastException的发生"></a>1.3怎么避免ClassCastException的发生</h4><p>   <strong>运算符instanceof</strong></p>
<p>   第一：instanceof可以在运行阶段动态判断引用指向对象的类型。</p>
<p>   第二：instanceof的语法</p>
<p>​               （引用 instanceof 类型）</p>
<p>   第三：instanceof运算符的运算结果是true&#x2F;false</p>
<p>   第四：c是一个引用，c变量保存了内存地址指向了堆中的对象。</p>
<p>​          假设（c instanceof cat）为true，则c引用指向的堆内存中的java对象是cat</p>
<p>​      反之，则不是cat。</p>
<p><strong>因此，向下转型前需要判断</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(s2 <span class="keyword">instanceof</span> cat)&#123;</span><br><span class="line">    cat x=(cat)s2;</span><br><span class="line">    x.catchMouse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在向下转型前判断s2是cat才继续进行，确保不会造成从鸟转换成猫的悲剧。</p>
<p><strong>任何时候向下转型时，必须使用instanceof，好习惯</strong></p>
<h4 id="1-4-为什么要用instanceof，自己判断是什么猫还是鸟不就行了吗"><a href="#1-4-为什么要用instanceof，自己判断是什么猫还是鸟不就行了吗" class="headerlink" title="1.4 为什么要用instanceof，自己判断是什么猫还是鸟不就行了吗"></a>1.4 为什么要用instanceof，自己判断是什么猫还是鸟不就行了吗</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(animal a)</span>&#123;</span><br><span class="line">    cat c=(cat)a;</span><br><span class="line">    c.catchMouse();</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这个test方法，被传过来的不确定是猫还是鸟，所以像上面这么写就容易发生异常，所以需要用instanceof。</span></span><br></pre></td></tr></table></figure>

<h3 id="3-多态在开发中的作用"><a href="#3-多态在开发中的作用" class="headerlink" title="3.多态在开发中的作用"></a>3.多态在开发中的作用</h3><p>比如主人喂养宠物，今天主人可能喜欢狗，喂的是狗，明天主人喜欢猫了，如果不使用多态，那就得再写一次喂狗的方法，软件的扩展性很差。</p>
<p>使用多态，<strong>能提高扩展性</strong>。编译的时候编译器发现Pet是pet类，会去pet中找eat方法，结果找到了，编译通过</p>
<p>运行的时候，底层实际的对象是什么，就自动调用到该实际对象对应的eat（</p>
<p>方法上，这就是多态的作用。</p>
<p>面向父类型编程，面向更加抽象进行编程，不建议面向具体编程。</p>
<p>一些多态练习的例子: 乐手弹奏不同的乐器，主人喂养不同的宠物、</p>
<h1 id="-4"><a href="#-4" class="headerlink" title=""></a></h1><h3 id="4-静态方法没有方法覆盖"><a href="#4-静态方法没有方法覆盖" class="headerlink" title="4.静态方法没有方法覆盖"></a>4.静态方法没有方法覆盖</h3><p>假设没有多态机制，只有方法覆盖机制，你觉得有意义吗？</p>
<p>​    没有多态机制的话，方法覆盖可有可无。</p>
<p>​     没有多态机制的话，方法覆盖也可以没有，如果父类的方法无法满足子类业务需求的时候，子类完全可以定义一个新的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Animal a=<span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">a.dosome();<span class="comment">//dosome为静态方法</span></span><br><span class="line"><span class="comment">//这样，虽然用引用.调用，但是静态方法，所以还是animal. ，起不到多态的作用，方法覆盖也没有意义。</span></span><br></pre></td></tr></table></figure>

<h4 id="5-私有方法不能覆盖"><a href="#5-私有方法不能覆盖" class="headerlink" title="5.私有方法不能覆盖"></a>5.私有方法不能覆盖</h4><p>私有不能覆盖，静态不谈覆盖。</p>
<h4 id="6-方法覆盖时返回值类型问题"><a href="#6-方法覆盖时返回值类型问题" class="headerlink" title="6.方法覆盖时返回值类型问题"></a>6.方法覆盖时返回值类型问题</h4><h5 id="6-1-基本数据类型"><a href="#6-1-基本数据类型" class="headerlink" title="6.1 基本数据类型"></a>6.1 基本数据类型</h5><p>方法覆盖前后的方法数据类型必须一致，该是int就是int</p>
<h5 id="6-2-引用数据类型"><a href="#6-2-引用数据类型" class="headerlink" title="6.2 引用数据类型"></a>6.2 引用数据类型</h5><p>父类时是ainimal，子类时是cat可以，java中允许。</p>
<p>父类时是animal 子类时是object，不行，java中不允许。</p>
<h2 id="十六-super"><a href="#十六-super" class="headerlink" title="十六.super"></a>十六.super</h2><p>1.super是一个关键字，全部小写。</p>
<p><strong>2.super和this对比着study。</strong></p>
<p> <strong>this：</strong></p>
<p>​      this能出现在实例方法中和构造方法中。</p>
<p>​     this语法是 this.和this（）</p>
<p>​      this不能用在静态方法中。</p>
<p>​      this大部分情况下可以省略、</p>
<p>​    this在区分局部变量和实例变量时候不能省略。</p>
<p>​    this（）只能出现在构造方法第一行，通过当前的构造方法去调用“本类”中的其他构造方法，目的是：代码复用。</p>
<p> <strong>super:</strong></p>
<p>   可以出现在实例方法和构造方法中。</p>
<p>​    super语法是 super.和super（）</p>
<p>   不能用在静态方法中。</p>
<p>   大部分情况下可以省略、</p>
<p>​    super什么时候不能省略呢？</p>
<p>​    super（）只能出现在构造方法第一行，通过当前的构造方法去调用父类中的其他构造方法，目的是：创建子类对象的时候，先初始化父类型特征。</p>
<h3 id="1-super"><a href="#1-super" class="headerlink" title="1.super()"></a>1.super()</h3><p>表示通过子类的构造方法调用父类的构造方法。</p>
<p>模拟现实世界中的这种场景：要想有儿子，先有父亲。</p>
<h3 id="2-重要结论"><a href="#2-重要结论" class="headerlink" title="2.重要结论"></a>2.重要结论</h3><p>当一个构造方法第一行：</p>
<p>既没有this（）也没有super（），会默认有一个super（）</p>
<p>表示通过当前子类的构造方法调用父类的无参数构造方法</p>
<p>所以必须保证父类的无参数构造方法存在（不然就报错了）。</p>
<p>this()和super()不能共存！</p>
<h1 id="-5"><a href="#-5" class="headerlink" title=""></a></h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">B</span><span class="params">()</span>&#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">B</span><span class="params">(String name)</span>&#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> <span class="keyword">extends</span> <span class="title class_">B</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">C</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>(<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">         System.out.println(<span class="string">&quot;4&quot;</span>);  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">C</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>(name,<span class="number">20</span>);</span><br><span class="line">         System.out.println(<span class="string">&quot;5&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">C</span><span class="params">(String name,id)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">         System.out.println(<span class="string">&quot;6&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果new一个c对象，输出结果是什么</p>
<p>​        <strong>13654</strong></p>
<h3 id="3-super（实参）是干啥的？"><a href="#3-super（实参）是干啥的？" class="headerlink" title="3.super（实参）是干啥的？"></a>3.super（实参）是干啥的？</h3><p>初始化当前对象的父类型特征，并不是创建新对象。[当你创建一个新对象，想初始化父类型特征，如果你在子类中用this.初始化，没用的，因为this.只能在本类（也就是父类）中用，因为引入super（）来初始化父类型特征]</p>
<h3 id="4-super关键字代表什么？"><a href="#4-super关键字代表什么？" class="headerlink" title="4.super关键字代表什么？"></a>4.super关键字代表什么？</h3><p>super关键字代表的就是“当前对象”的那部分父类型特征。</p>
<p>例如：</p>
<p>我继承了我父亲的一部分特征：</p>
<p>​        例如：眼睛、皮肤等。</p>
<p>​        super代表的就是“眼睛、皮肤等”</p>
<p>​        “眼睛、皮肤等”虽然是继承了父亲的，但这部分是在我身上呢。</p>
<p><img src="E:\study\后端\java\image\super.jpg" alt="super"></p>
<h3 id="5-super-什么时候不能省略"><a href="#5-super-什么时候不能省略" class="headerlink" title="5.super.什么时候不能省略"></a>5.super.什么时候不能省略</h3><p> 父中有，子中又有，如果想在子中访问“父的特征”，super.不能省略。</p>
<p><strong>java中</strong></p>
<p>this.name ：当前对象的name属性。</p>
<p>super.name：当前对象的父类型特征的name属性。</p>
<h4 id="6-super和this"><a href="#6-super和this" class="headerlink" title="6.super和this"></a>6.super和this</h4><p>直接输出this，会自动引用this的toString方法</p>
<p>直接输出super，会报错</p>
<p><strong>结论</strong></p>
<p>super不是引用，super也不保存内存地址，super也不指向任何对象。</p>
<p>super只是代表当前对象内部的那一块父类型的特征。</p>
<h2 id="-6"><a href="#-6" class="headerlink" title=""></a></h2>
    </article>
    
    <div class="read-nums">
      <!-- id 将作为查询条件 -->
      <span id="2023/08/31/java-0/" class="leancloud_visitors" data-flag-title="Your Article Title">
        <em class="post-meta-item-text">浏览量</em>
        <i class="leancloud-visitors-count"></i>
      </span>
    </div>
    <div class="comments-intro">
      <h2>评论区</h2>
      <p>欢迎你留下宝贵的意见，昵称输入QQ号会显示QQ头像哦~</p>
    </div>
    <div id="vcomments" class="vcomments"></div>
    
  </div>
  <div class="article-catelogue">
    <div class="article-catelogue--wrapper">
      <div class="catelogue catelogue-1">
        <h3>目录</h3>
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#JAVA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA"><span class="toc-number">1.</span> <span class="toc-text">JAVA开发环境的搭建</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84Dos%E5%91%BD%E4%BB%A4"><span class="toc-number">1.1.</span> <span class="toc-text">常用的Dos命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFDos%E5%91%BD%E4%BB%A4"><span class="toc-number">1.1.1.</span> <span class="toc-text">什么是Dos命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mkdir-abc"><span class="toc-number">1.1.2.</span> <span class="toc-text">mkdir abc</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8Dos%E7%AA%97%E5%8F%A3%E4%B8%AD%E6%80%8E%E4%B9%88%E5%A4%8D%E5%88%B6%E5%86%85%E5%AE%B9"><span class="toc-number">1.1.3.</span> <span class="toc-text">在Dos窗口中怎么复制内容</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%87%E6%8D%A2%E7%9B%98%E7%AC%A6"><span class="toc-number">1.1.4.</span> <span class="toc-text">切换盘符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%87%E6%8D%A2%E7%9B%AE%E5%BD%95"><span class="toc-number">1.1.5.</span> <span class="toc-text">切换目录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E6%9F%A5%E7%9C%8B%E4%B8%A4%E5%8F%B0%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8F%AF%E4%BB%A5%E6%AD%A3%E5%B8%B8%E9%80%9A%E4%BF%A1"><span class="toc-number">1.1.6.</span> <span class="toc-text">怎么查看两台计算机可以正常通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%B5%E8%84%91%E5%BF%AB%E6%8D%B7%E9%94%AE"><span class="toc-number">1.1.7.</span> <span class="toc-text">电脑快捷键</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E6%9C%AC%E5%BF%AB%E6%8D%B7%E9%94%AE"><span class="toc-number">1.1.8.</span> <span class="toc-text">文本快捷键</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#java%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7"><span class="toc-number">1.2.</span> <span class="toc-text">java语言特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E6%80%A7"><span class="toc-number">1.2.1.</span> <span class="toc-text">简单性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%87%8D%E8%A6%81%E9%83%A8%E4%BB%B6"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">计算机重要部件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#java%E6%98%AF%E5%A0%AA%E7%A7%B0%E5%AE%8C%E5%85%A8%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">java是堪称完全面向对象的</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%81%A5%E5%A3%AE%E6%80%A7"><span class="toc-number">1.2.2.</span> <span class="toc-text">健壮性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#JVM"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">JVM</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E7%A7%BB%E6%A4%8D%E6%80%A7-%E8%B7%A8%E5%B9%B3%E5%8F%B0"><span class="toc-number">1.2.3.</span> <span class="toc-text">可移植性&#x2F;跨平台</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#JDK%E3%80%81JRE%E3%80%81JVM%E4%B8%89%E8%80%85%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">JDK、JRE、JVM三者之间的关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#java%E4%BB%8E%E7%BC%96%E8%AF%91%E5%88%B0%E8%BF%90%E8%A1%8C"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">java从编译到运行</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#java%E4%BD%BF%E7%94%A8"><span class="toc-number">1.3.</span> <span class="toc-text">java使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#java%E4%B8%8B%E8%BD%BD%E4%BB%A5%E5%8F%8A%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE"><span class="toc-number">1.3.1.</span> <span class="toc-text">java下载以及环境变量配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#javac%E5%91%BD%E4%BB%A4%E6%80%8E%E4%B9%88%E7%94%A8"><span class="toc-number">1.3.2.</span> <span class="toc-text">javac命令怎么用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java%E5%91%BD%E4%BB%A4"><span class="toc-number">1.3.3.</span> <span class="toc-text">java命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#classpath%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="toc-number">1.3.4.</span> <span class="toc-text">classpath环境变量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#java%E6%B3%A8%E9%87%8A"><span class="toc-number">1.4.</span> <span class="toc-text">java注释</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E4%BD%93"><span class="toc-number">1.5.</span> <span class="toc-text">类体</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95"><span class="toc-number">1.6.</span> <span class="toc-text">方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#main%E6%96%B9%E6%B3%95"><span class="toc-number">1.6.1.</span> <span class="toc-text">main方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#class"><span class="toc-number">1.6.2.</span> <span class="toc-text">class</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#public-class"><span class="toc-number">1.6.3.</span> <span class="toc-text">public class</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%87%E8%AF%86%E7%AC%A6%E4%B8%8E%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">2.</span> <span class="toc-text">标识符与关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%87%E8%AF%86%E7%AC%A6%E5%8F%AF%E4%BB%A5%E6%A0%87%E8%AF%86%E4%BB%80%E4%B9%88"><span class="toc-number">2.1.</span> <span class="toc-text">标识符可以标识什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E4%BB%A5%E5%91%BD%E5%90%8D123-java%E5%90%97"><span class="toc-number">2.2.</span> <span class="toc-text">可以命名123.java吗</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%84%E8%8C%83"><span class="toc-number">2.3.</span> <span class="toc-text">规范</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">2.4.</span> <span class="toc-text">.关键字</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%98%E9%87%8F"><span class="toc-number">3.</span> <span class="toc-text">变量</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E9%9D%A2%E9%87%8F"><span class="toc-number">3.1.</span> <span class="toc-text">字面量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E9%87%8F-1"><span class="toc-number">3.2.</span> <span class="toc-text">变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E5%88%86%E7%B1%BB"><span class="toc-number">3.3.</span> <span class="toc-text">变量分类</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.</span> <span class="toc-text">数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B4%E5%9E%8B"><span class="toc-number">4.1.</span> <span class="toc-text">整型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.1.1.</span> <span class="toc-text">基本数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.1.2.</span> <span class="toc-text">引用数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB"><span class="toc-number">4.1.3.</span> <span class="toc-text">区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%A0%E7%94%A8%E5%AD%97%E8%8A%82%E6%95%B0%E9%87%8F"><span class="toc-number">4.1.4.</span> <span class="toc-text">占用字节数量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%96%E5%80%BC%E8%8C%83%E5%9B%B4"><span class="toc-number">4.1.5.</span> <span class="toc-text">取值范围</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81"><span class="toc-number">4.1.6.</span> <span class="toc-text">字符编码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6"><span class="toc-number">4.1.7.</span> <span class="toc-text">转义字符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E5%88%B6"><span class="toc-number">4.1.8.</span> <span class="toc-text">进制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E5%9E%8B%E8%A2%AB%E9%BB%98%E8%AE%A4%E5%BD%93%E5%81%9Aint%E5%A4%84%E7%90%86"><span class="toc-number">4.1.9.</span> <span class="toc-text">整数型被默认当做int处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">4.1.10.</span> <span class="toc-text">自动类型转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">4.1.11.</span> <span class="toc-text">强制类型转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E8%83%BD%E5%90%A6%E7%9B%B4%E6%8E%A5%E8%B5%8B%E5%80%BC%E7%BB%99char"><span class="toc-number">4.1.12.</span> <span class="toc-text">整数能否直接赋值给char</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A5%E7%A0%81"><span class="toc-number">4.1.13.</span> <span class="toc-text">二进制补码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%A1%A5%E7%A0%81"><span class="toc-number">4.1.13.1.</span> <span class="toc-text">什么是补码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#char-byte"><span class="toc-number">4.1.14.</span> <span class="toc-text">char+byte</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%A7%8D%E7%B1%BB%E5%9E%8B%E8%BF%90%E7%AE%97"><span class="toc-number">4.1.15.</span> <span class="toc-text">多种类型运算</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E5%9E%8B"><span class="toc-number">4.2.</span> <span class="toc-text">浮点型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#boolean%E5%9E%8B"><span class="toc-number">4.3.</span> <span class="toc-text">boolean型</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">5.</span> <span class="toc-text">运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%AD%E8%B7%AF"><span class="toc-number">5.1.</span> <span class="toc-text">短路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#i-i-1%E5%92%8Ci-1%E7%9C%9F%E7%9A%84%E4%B8%80%E6%A0%B7%E5%90%97%EF%BC%9F%EF%BC%9F%EF%BC%9F"><span class="toc-number">5.2.</span> <span class="toc-text">i&#x3D;i+1和i+&#x3D;1真的一样吗？？？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E7%9B%AE%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">5.3.</span> <span class="toc-text">三目运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%88%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5%EF%BC%89"><span class="toc-number">5.4.</span> <span class="toc-text">运算符（字符串拼接）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E5%AE%9A%E4%B9%89%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%9E%8B%E5%8F%98%E9%87%8F"><span class="toc-number">5.5.</span> <span class="toc-text">如果定义字符串型变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD-%E6%8E%A5%E6%94%B6%E7%94%A8%E6%88%B7%E9%94%AE%E7%9B%98%E8%BE%93%E5%85%A5%EF%BC%88%E5%85%88%E4%B8%8D%E7%94%A8%E7%90%86%E8%A7%A3%EF%BC%89-%E9%80%80%E5%87%BAJVM"><span class="toc-number">5.6.</span> <span class="toc-text">六.接收用户键盘输入（先不用理解）+退出JVM</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83-if-%E4%B8%89%E7%9B%AE-Switch"><span class="toc-number">5.7.</span> <span class="toc-text">七.if 三目 Switch</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Switch"><span class="toc-number">5.7.0.1.</span> <span class="toc-text">1.Switch</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB-%E8%BD%AC%E5%90%91%E8%AF%AD%E5%8F%A5"><span class="toc-number">5.8.</span> <span class="toc-text">八.转向语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%9D-%E6%96%B9%E6%B3%95"><span class="toc-number">5.9.</span> <span class="toc-text">九.方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%BF%94%E5%9B%9E%E5%80%BC%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.9.0.1.</span> <span class="toc-text">1.返回值类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%BF%94%E5%9B%9E%E5%80%BC%E7%B1%BB%E5%9E%8B%E4%B8%8D%E6%98%AFvoid%EF%BC%8C%E5%B0%B1%E5%BF%85%E9%A1%BB%E6%9C%89return"><span class="toc-number">5.9.0.2.</span> <span class="toc-text">2.返回值类型不是void，就必须有return</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E7%B1%BB%E5%90%8D%E7%9C%81%E7%95%A5"><span class="toc-number">5.9.0.3.</span> <span class="toc-text">3.类名省略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-return-%E7%94%A8%E6%9D%A5%E7%BB%88%E6%AD%A2%E7%A6%BB%E4%BB%96%E6%9C%80%E8%BF%91%E7%9A%84%E4%B8%80%E4%B8%AA%E6%96%B9%E6%B3%95%E3%80%82"><span class="toc-number">5.9.0.4.</span> <span class="toc-text">4.return 用来终止离他最近的一个方法。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E7%BC%BA%E5%B0%91%E8%BF%94%E5%9B%9E%E8%AF%AD%E5%8F%A5"><span class="toc-number">5.9.0.5.</span> <span class="toc-text">5.缺少返回语句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-JVM%EF%BC%88java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%89%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84"><span class="toc-number">5.9.0.6.</span> <span class="toc-text">6.JVM（java虚拟机）内存结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%86%85%E5%AD%98%E5%8F%98%E5%8C%96"><span class="toc-number">5.9.0.7.</span> <span class="toc-text">7.方法执行过程中内存变化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD"><span class="toc-number">5.9.0.8.</span> <span class="toc-text">8.方法重载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-%E5%87%BD%E6%95%B0%E9%80%92%E5%BD%92"><span class="toc-number">5.9.0.9.</span> <span class="toc-text">9.函数递归</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">5.10.</span> <span class="toc-text">十.面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E5%8C%BA%E5%88%AB"><span class="toc-number">5.10.1.</span> <span class="toc-text">1.面向对象和面向过程区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-OOA-OOD-OOP"><span class="toc-number">5.10.2.</span> <span class="toc-text">2. OOA OOD OOP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%8C%E5%90%8E%E9%9D%A2%E8%AE%B2%EF%BC%89"><span class="toc-number">5.10.3.</span> <span class="toc-text">3.面向对象三大特征（了解，后面讲）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">5.10.4.</span> <span class="toc-text">4.类和对象的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-java%E7%A8%8B%E5%BA%8F%E5%91%98%E6%98%AF%E4%B8%80%E4%B8%AA%E8%BD%AC%E6%8D%A2%E7%9A%84%E6%A1%A5%E6%A2%81"><span class="toc-number">5.10.5.</span> <span class="toc-text">5.java程序员是一个转换的桥梁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">5.10.6.</span> <span class="toc-text">6.类的定义</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-%E6%80%8E%E4%B9%88%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E7%B1%BB%EF%BC%9F"><span class="toc-number">5.10.6.1.</span> <span class="toc-text">6.1 怎么定义一个类？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">5.10.6.2.</span> <span class="toc-text">6.2对象的创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B"><span class="toc-number">5.10.6.3.</span> <span class="toc-text">6.3 编译过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E5%AF%B9%E5%BA%94%E7%9A%84jvm%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84"><span class="toc-number">5.10.6.4.</span> <span class="toc-text">6.4创建对象对应的jvm内存结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-5-%E5%86%85%E5%AD%98%E5%9B%BE"><span class="toc-number">5.10.6.5.</span> <span class="toc-text">6.5 内存图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-6-%E5%BC%95%E7%94%A8%E4%B8%80%E5%AE%9A%E6%98%AF%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E5%90%97%EF%BC%9F"><span class="toc-number">5.10.6.6.</span> <span class="toc-text">6.6 引用一定是局部变量吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-7-%E5%B1%9E%E6%80%A7%E6%98%AF%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E6%80%8E%E4%B9%88%E8%AE%BF%E9%97%AE%E3%80%82"><span class="toc-number">5.10.6.7.</span> <span class="toc-text">6.7 属性是引用类型怎么访问。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-8%E7%A9%BA%E6%8C%87%E9%92%88%E5%BC%82%E5%B8%B8%EF%BC%88NullPointerException%EF%BC%89"><span class="toc-number">5.10.6.8.</span> <span class="toc-text">6.8空指针异常（NullPointerException）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-9%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E6%97%B6%E5%8F%82%E6%95%B0%E7%9A%84%E4%BC%A0%E9%80%92%E9%97%AE%E9%A2%98"><span class="toc-number">5.10.6.9.</span> <span class="toc-text">6.9方法调用时参数的传递问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">5.10.7.</span> <span class="toc-text">7.构造方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1%E4%BB%80%E4%B9%88%E6%98%AF%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F"><span class="toc-number">5.10.7.1.</span> <span class="toc-text">7.1什么是构造方法，有什么用？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-%E5%BD%93%E4%B8%80%E4%B8%AA%E7%B1%BB%E6%B2%A1%E6%9C%89%E6%8F%90%E4%BE%9B%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E6%97%B6%EF%BC%8C%E7%B3%BB%E7%BB%9F%E4%BC%9A%E9%BB%98%E8%AE%A4%E6%8F%90%E4%BE%9B%E4%B8%80%E4%B8%AA%E6%97%A0%E5%8F%82%E6%95%B0%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%EF%BC%88%E8%BF%99%E4%B8%AA%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E8%A2%AB%E7%A7%B0%E4%B8%BA%E7%BC%BA%E7%9C%81%E6%9E%84%E9%80%A0%E5%99%A8%EF%BC%89%E3%80%82%E4%BD%86%E6%98%AF%E5%BD%93%E4%B8%80%E4%B8%AA%E7%B1%BB%E4%B8%AD%E6%8F%90%E4%BE%9B%E4%BA%86%E6%96%B9%E6%B3%95%E6%97%B6%EF%BC%8C%E7%B3%BB%E7%BB%9F%E5%B0%B1%E4%B8%8D%E4%BC%9A%E5%86%8D%E6%8F%90%E4%BE%9B%E9%82%A3%E4%B8%80%E4%B8%AA%E6%97%A0%E5%8F%82%E6%95%B0%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E4%BA%86%EF%BC%8C%E8%BF%99%E6%97%B6%E4%BD%A0%E6%83%B3%E8%B0%83%E7%94%A8%E6%97%A0%E5%8F%82%E7%9A%84%E8%BF%99%E4%B8%AA%E6%96%B9%E6%B3%95%EF%BC%8C%E5%B0%B1%E4%BC%9A%E6%8A%A5%E9%94%99"><span class="toc-number">5.10.7.2.</span> <span class="toc-text">7.2 当一个类没有提供构造方法时，系统会默认提供一个无参数的构造方法（这个构造方法被称为缺省构造器）。但是当一个类中提供了方法时，系统就不会再提供那一个无参数的构造方法了，这时你想调用无参的这个方法，就会报错</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E5%A6%82%E4%BD%95%E8%B0%83%E7%94%A8%EF%BC%9F"><span class="toc-number">5.10.7.3.</span> <span class="toc-text">7.3构造方法如何调用？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-4-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E7%9A%84%E8%AF%AD%E6%B3%95%E7%BB%93%E6%9E%84%E6%98%AF%EF%BC%9F"><span class="toc-number">5.10.7.4.</span> <span class="toc-text">7.4 构造方法的语法结构是？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-5-%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E5%88%9D%E5%A7%8B%E5%8C%96%E5%95%A5%E6%97%B6%E5%80%99%EF%BC%9F"><span class="toc-number">5.10.7.5.</span> <span class="toc-text">7.5 实例变量初始化啥时候？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%B8%80-%E5%B0%81%E8%A3%85"><span class="toc-number">5.11.</span> <span class="toc-text">十一.封装</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81"><span class="toc-number">5.11.1.</span> <span class="toc-text">1.面向对象的三大特征</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%A6%96%E8%A6%81%E7%89%B9%E5%BE%81%EF%BC%9A%E5%B0%81%E8%A3%85"><span class="toc-number">5.11.2.</span> <span class="toc-text">2.面向对象的首要特征：封装</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E4%BB%80%E4%B9%88%E6%98%AF%E5%B0%81%E8%A3%85%EF%BC%9F"><span class="toc-number">5.11.2.1.</span> <span class="toc-text">2.1 什么是封装？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E5%B0%81%E8%A3%85%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F"><span class="toc-number">5.11.2.2.</span> <span class="toc-text">2.2 封装有什么用？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E4%BF%9D%E8%AF%81%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84%E5%AE%89%E5%85%A8"><span class="toc-number">5.11.2.2.1.</span> <span class="toc-text">1.保证内部结构安全</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%B1%8F%E8%94%BD%E5%A4%8D%E6%9D%82%EF%BC%8C%E6%9A%B4%E9%9C%B2%E7%AE%80%E5%8D%95"><span class="toc-number">5.11.2.2.2.</span> <span class="toc-text">2.屏蔽复杂，暴露简单</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">5.11.2.3.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3%E4%B8%8D%E5%B0%81%E8%A3%85%E6%9C%89%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98"><span class="toc-number">5.11.2.4.</span> <span class="toc-text">2.3不封装有什么问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4%E5%B0%9D%E8%AF%95%E5%B0%81%E8%A3%85%E4%B8%80%E4%B8%8B"><span class="toc-number">5.11.2.5.</span> <span class="toc-text">2.4尝试封装一下</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5%E6%80%8E%E4%B9%88%E8%BF%9B%E8%A1%8C%E5%B0%81%E8%A3%85%EF%BC%9F"><span class="toc-number">5.11.2.6.</span> <span class="toc-text">2.5怎么进行封装？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%AD%E9%97%B4%E5%BC%95%E5%85%A5%E4%B8%80%E4%B8%AA%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95"><span class="toc-number">5.11.2.6.1.</span> <span class="toc-text">中间引入一个实例方法</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%B8%A6%E6%9C%89static%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">5.11.2.6.1.1.</span> <span class="toc-text">带有static的方法</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B8%8D%E5%B8%A6static%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">5.11.2.6.1.2.</span> <span class="toc-text">不带static的方法</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%86%E5%88%AB%E6%80%8E%E4%B9%88%E8%B0%83%E7%94%A8%EF%BC%9F"><span class="toc-number">5.11.2.6.1.3.</span> <span class="toc-text">分别怎么调用？</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#-1"><span class="toc-number">6.</span> <span class="toc-text"></span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%BA%8C-static"><span class="toc-number">6.1.</span> <span class="toc-text">十二 static</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-static"><span class="toc-number">6.1.1.</span> <span class="toc-text">1.static</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8%E9%9D%99%E6%80%81%E7%9A%84%EF%BC%8C%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8%E5%AE%9E%E4%BE%8B%E7%9A%84%E3%80%82"><span class="toc-number">6.1.2.</span> <span class="toc-text">2.什么时候用静态的，什么时候用实例的。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%A9%BA%E5%BC%95%E7%94%A8%E8%AE%BF%E9%97%AE%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F"><span class="toc-number">6.1.3.</span> <span class="toc-text">3.空引用访问静态变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%85%B3%E4%BA%8E%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8"><span class="toc-number">6.1.4.</span> <span class="toc-text">4.关于实例方法的调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-number">6.1.5.</span> <span class="toc-text">5.静态代码块</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1%E4%BD%BF%E7%94%A8static%E5%8F%AF%E4%BB%A5%E5%AE%9A%E4%B9%89%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-number">6.1.5.1.</span> <span class="toc-text">5.1使用static可以定义静态代码块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2%E4%BB%80%E4%B9%88%E6%98%AF%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97%EF%BC%9F"><span class="toc-number">6.1.5.2.</span> <span class="toc-text">5.2什么是静态代码块？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3static%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E6%89%A7%E8%A1%8C%E5%91%A2%EF%BC%9F"><span class="toc-number">6.1.5.3.</span> <span class="toc-text">5.3static静态代码块什么时候执行呢？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F"><span class="toc-number">6.1.5.4.</span> <span class="toc-text">5.4静态代码块有什么用？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-5-%E5%85%88%E5%90%8E%E9%A1%BA%E5%BA%8F"><span class="toc-number">6.1.5.5.</span> <span class="toc-text">5.5 先后顺序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%AE%9E%E4%BE%8B%E8%AF%AD%E5%8F%A5%E5%9D%97"><span class="toc-number">6.1.6.</span> <span class="toc-text">6.实例语句块</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1%E5%AE%9E%E5%8A%9B%E8%AF%AD%E5%8F%A5%E5%9D%97%E8%AF%AD%E6%B3%95"><span class="toc-number">6.1.6.1.</span> <span class="toc-text">6.1实力语句块语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2%E5%AE%9E%E4%BE%8B%E8%AF%AD%E5%8F%A5%E5%9D%97%E4%B8%8D%E6%98%AF%E5%9C%A8%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%97%B6%E6%89%A7%E8%A1%8C"><span class="toc-number">6.1.6.2.</span> <span class="toc-text">6.2实例语句块不是在类加载时执行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3%E5%AE%9E%E4%BE%8B%E8%AF%AD%E5%8F%A5%E5%9D%97%E5%9C%A8%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%E4%B9%8B%E5%89%8D%E6%89%A7%E8%A1%8C%E3%80%82"><span class="toc-number">6.1.6.3.</span> <span class="toc-text">6.3实例语句块在构造方法执行之前执行。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4%E5%AE%9E%E4%BE%8B%E8%AF%AD%E5%8F%A5%E5%9D%97%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8"><span class="toc-number">6.1.6.4.</span> <span class="toc-text">6.4实例语句块有什么用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%B8%89-this"><span class="toc-number">6.2.</span> <span class="toc-text">十三.this</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-this%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">6.2.1.</span> <span class="toc-text">1.this的应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-this%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%B8%8D%E8%83%BD%E7%9C%81%E7%95%A5%EF%BC%9F"><span class="toc-number">6.2.2.</span> <span class="toc-text">2.this什么时候不能省略？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E9%80%9A%E8%BF%87this%EF%BC%88%EF%BC%89%E5%9C%A8%E4%B8%80%E4%B8%AA%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E9%87%8C%E8%B0%83%E7%94%A8%E5%8F%A6%E4%B8%80%E4%B8%AA%E3%80%82"><span class="toc-number">6.2.3.</span> <span class="toc-text">3.通过this（）在一个构造方法里调用另一个。</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#-2"><span class="toc-number">7.</span> <span class="toc-text"></span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E5%9B%9B-%E7%BB%A7%E6%89%BFextends"><span class="toc-number">7.1.</span> <span class="toc-text">十四.继承extends</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E7%BB%A7%E6%89%BF%EF%BC%9F"><span class="toc-number">7.1.1.</span> <span class="toc-text">1.什么是继承？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BD%9C%E7%94%A8"><span class="toc-number">7.1.2.</span> <span class="toc-text">2.作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%BB%A7%E6%89%BF%E7%9A%84%E7%9B%B8%E5%85%B3%E7%89%B9%E6%80%A7"><span class="toc-number">7.1.3.</span> <span class="toc-text">3.继承的相关特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8%E7%BB%A7%E6%89%BF"><span class="toc-number">7.1.4.</span> <span class="toc-text">4.什么时候用继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-object%E7%B1%BB%E4%B8%AD%E7%9A%84toString%E6%96%B9%E6%B3%95"><span class="toc-number">7.1.5.</span> <span class="toc-text">5.object类中的toString方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#-3"><span class="toc-number">8.</span> <span class="toc-text"></span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%BA%94-%E6%96%B9%E6%B3%95%E7%9A%84%E8%A6%86%E7%9B%96%E5%92%8C%E5%A4%9A%E6%80%81"><span class="toc-number">8.1.</span> <span class="toc-text">十五.方法的覆盖和多态</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%96%B9%E6%B3%95%E8%A6%86%E7%9B%96override"><span class="toc-number">8.1.1.</span> <span class="toc-text">1.方法覆盖override</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BDoverload%EF%BC%88%E5%9B%9E%E9%A1%BE%EF%BC%89"><span class="toc-number">8.1.1.1.</span> <span class="toc-text">1.1什么时候方法重载overload（回顾）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2%E6%96%B9%E6%B3%95%E8%A6%86%E7%9B%96%E4%BE%8B%E5%AD%90"><span class="toc-number">8.1.1.2.</span> <span class="toc-text">1.2方法覆盖例子</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3%E6%96%B9%E6%B3%95%E8%A6%86%E7%9B%96%E6%9D%A1%E4%BB%B6"><span class="toc-number">8.1.1.3.</span> <span class="toc-text">1.3方法覆盖条件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">8.1.1.4.</span> <span class="toc-text">1.4注意事项</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%A4%9A%E6%80%81%E7%9A%84%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95"><span class="toc-number">8.1.2.</span> <span class="toc-text">2.多态的基础语法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B"><span class="toc-number">8.1.2.1.</span> <span class="toc-text">1.1向上转型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2%E5%90%91%E4%B8%8B%E8%BD%AC%E5%9E%8B"><span class="toc-number">8.1.2.2.</span> <span class="toc-text">1.2向下转型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3%E6%80%8E%E4%B9%88%E9%81%BF%E5%85%8DClassCastException%E7%9A%84%E5%8F%91%E7%94%9F"><span class="toc-number">8.1.2.3.</span> <span class="toc-text">1.3怎么避免ClassCastException的发生</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8instanceof%EF%BC%8C%E8%87%AA%E5%B7%B1%E5%88%A4%E6%96%AD%E6%98%AF%E4%BB%80%E4%B9%88%E7%8C%AB%E8%BF%98%E6%98%AF%E9%B8%9F%E4%B8%8D%E5%B0%B1%E8%A1%8C%E4%BA%86%E5%90%97"><span class="toc-number">8.1.2.4.</span> <span class="toc-text">1.4 为什么要用instanceof，自己判断是什么猫还是鸟不就行了吗</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%A4%9A%E6%80%81%E5%9C%A8%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">8.1.3.</span> <span class="toc-text">3.多态在开发中的作用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#-4"><span class="toc-number">9.</span> <span class="toc-text"></span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E6%B2%A1%E6%9C%89%E6%96%B9%E6%B3%95%E8%A6%86%E7%9B%96"><span class="toc-number">9.0.1.</span> <span class="toc-text">4.静态方法没有方法覆盖</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95%E4%B8%8D%E8%83%BD%E8%A6%86%E7%9B%96"><span class="toc-number">9.0.1.1.</span> <span class="toc-text">5.私有方法不能覆盖</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E6%96%B9%E6%B3%95%E8%A6%86%E7%9B%96%E6%97%B6%E8%BF%94%E5%9B%9E%E5%80%BC%E7%B1%BB%E5%9E%8B%E9%97%AE%E9%A2%98"><span class="toc-number">9.0.1.2.</span> <span class="toc-text">6.方法覆盖时返回值类型问题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#6-1-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">9.0.1.2.1.</span> <span class="toc-text">6.1 基本数据类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-2-%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">9.0.1.2.2.</span> <span class="toc-text">6.2 引用数据类型</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E5%85%AD-super"><span class="toc-number">9.1.</span> <span class="toc-text">十六.super</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-super"><span class="toc-number">9.1.1.</span> <span class="toc-text">1.super()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%87%8D%E8%A6%81%E7%BB%93%E8%AE%BA"><span class="toc-number">9.1.2.</span> <span class="toc-text">2.重要结论</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#-5"><span class="toc-number">10.</span> <span class="toc-text"></span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-super%EF%BC%88%E5%AE%9E%E5%8F%82%EF%BC%89%E6%98%AF%E5%B9%B2%E5%95%A5%E7%9A%84%EF%BC%9F"><span class="toc-number">10.0.1.</span> <span class="toc-text">3.super（实参）是干啥的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-super%E5%85%B3%E9%94%AE%E5%AD%97%E4%BB%A3%E8%A1%A8%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">10.0.2.</span> <span class="toc-text">4.super关键字代表什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-super-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%B8%8D%E8%83%BD%E7%9C%81%E7%95%A5"><span class="toc-number">10.0.3.</span> <span class="toc-text">5.super.什么时候不能省略</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-super%E5%92%8Cthis"><span class="toc-number">10.0.3.1.</span> <span class="toc-text">6.super和this</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#-6"><span class="toc-number">10.1.</span> <span class="toc-text"></span></a></li></ol></li></ol>
      </div>
      
        <div class="catelogue catelogue-2">
          
            <p>
              <span>上一篇：</span>
              <a href="/2023/09/01/图片上传-1/">图片上传</a>
            </p>
           
          
        </div>
      
    </div>
  </div>
</div>


<script>
  // var定义，避免pjax重新进来造成的重复声明错误
  var config = JSON.parse('{"enable":true,"appId":"Pf8zCXGEH1qsprnWfikVVujL-gzGzoHsz","appKey":"qOqoiUHhH1TGtLRUYURkLRQX","placeholder":"请留下你宝贵的意见吧~","meta":["nick"],"recordIP":true,"visitor":true,"enableQQ":true}')
  new Valine({
    el: '#vcomments',
    appId: config.appId,
    appKey: config.appKey,
    placeholder: config.placeholder,
    meta: config.meta,
    recordIP: config.recordIP,
    visitor: config.visitor,
    enableQQ: config.enableQQ,
    path: '2023/08/31/java-0/'
  })
</script>


<script>
  $(document).on('pjax:complete', function() {
    const tocs = document.querySelector('.toc')
    const links = tocs ? tocs.querySelectorAll('a') : []
    links.forEach(link => {
      link.addEventListener('click', e => {
        const href = decodeURIComponent(e.href)
        href.search(/#(.*)/)
        const id = RegExp.$1
        const target = document.querySelector('#' + id)
        const top = target.offsetTop
        document.documentElement.scrollTo({
          top: top - 100,
          behavior: 'smooth'
        })
        e.preventDefault()
      })
    })
  })
</script> 

</div>
      <div class="main-right-wrapper"><div class="main-right">
  <div class="main-right--board">
    <div class="main-right--title">
      <h5>公告栏</h5>
      <i class="iconfont icon-gonggao"></i>
    </div>
    <div class="main-right--content">
      Hello~大家好。我是iYaovo，欢迎你们来到我的博客小站，希望能在这里收获到有用的东西哦！ 
    </div>
  </div>

  <div id="aplayer" class="main-right--music"></div>

  <div class="operate-items">
    <div class="operate-item backtop">
      <i class="iconfont icon-huidaodingbu"></i>
      <span>回到顶部</span>
    </div>
    
    <div class="operate-item turn-comment hidden">
      <i class="iconfont icon-pinglun"></i>
      <span>查看评论</span>
    </div>
    
  </div>

  <div class="main-right--site">
    <div class="main-right--power">
      <p>Power By <a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/docs/">Hexo</a>.</p>
      <p>Theme：<a target="_blank" rel="noopener" href="https://github.com/Aizener/hexo-theme-cola">Cola.</a></p>
    </div>
    <p class="main-right--refer"><a target="_blank" rel="noopener" href="https://beian.miit.gov.cn/#/Integrated/index">蜀ICP备2022005384号-1</a> </p>
  </div>
</div>

<script>
  function setOperateItem () {
    const reg = /\d{4}\/\d{2}\/\d{2}\/.+/
    const path = location.pathname
    const operateDom = document.querySelector('.main-right .operate-items')
    const commentDom = document.querySelector('.turn-comment')
    const cateloguDom = document.querySelector('.article-catelogue > .article-catelogue--wrapper');

    if (commentDom) {
      if (reg.test(path) || path.match(/\/log\/.+/)) {
        commentDom.classList.remove('hidden')
        const newDom = operateDom.cloneNode(true);
        const _backtopDom = newDom.querySelector('.backtop');
        const _commentDom = newDom.querySelector('.turn-comment');
        _backtopDom.addEventListener('click', () => backTopEvent());
        _commentDom.addEventListener('click', () => commentDomEvent());
        cateloguDom.appendChild(newDom);
      } else {
        commentDom.classList.add('hidden')
      }
    }
  }

  setOperateItem()
  const musics = JSON.parse(`[{"name":"如果呢","artist":"郑润泽","url":"music/如果呢.mp3","cover":"https://pic.jitapai.com/wp-content/uploads/2021/06/2021062207282652.png"},{"name":"忘不掉的你","artist":"h3R3","url":"music/忘不掉的你.mp3","cover":"https://pic.jitapai.com/wp-content/uploads/2022/03/2022031407481132.jpg"},{"name":"明天","artist":"马思唯","url":"music/明天.mp3","cover":"https://tse4-mm.cn.bing.net/th/id/OIP-C.nzzINQpsCrL76xe4WYqmBQHaHa?pid=ImgDet&rs=1"}]`)
  const ap = new APlayer({
    container: document.querySelector('#aplayer'),
    audio: musics,
  })

  $(document).on('pjax:complete', function() {
    setOperateItem()
  })

  document.querySelector('.backtop').addEventListener('click', () => {
    backTopEvent();
  })
  const dom = document.querySelector('.turn-comment')
  dom && dom.addEventListener('click', () => {
    commentDomEvent();
  })

  function backTopEvent() {
    document.documentElement.scrollTo({
      top: 0,
      behavior: 'smooth'
    })
  }

  function commentDomEvent() {
    const commentDom = document.querySelector('.comments-intro')
    if (!commentDom) return
    const top = commentDom.offsetTop, height = commentDom.offsetHeight
    document.documentElement.scrollTo({
      top: top - 2 * height,
      behavior: 'smooth'
    })
  }
</script></div>
    </section>
  </div>
  <div id="progress" class="progress"></div>
  <div id="gray" class="gray"></div>

  <script>
    function initScroll () {
      document.addEventListener('scroll', () => {
        const doc = document.documentElement
        const scrollTop = doc.scrollTop
        const pageHeight = doc.offsetHeight
        const clientHeight = doc.clientHeight
        const ratio = scrollTop / (pageHeight - clientHeight)
        const progress = document.querySelector('#progress')
        const avatarImg = document.querySelector('.main-left--avatar')
        progress.style.width = (100 * ratio) + '%'
        avatarImg.style.transform = `rotate(${360 * ratio}deg)`
      })
    }

    const rootPath = "/"

    const checkAndSetArticlePageLayout = () => {
      const path = location.pathname.replace(rootPath, '');
      if (
        /^\/?\d{4}\/\d{2}\/\d{2}\/.*/.test(path) ||
        /^log\/.+/.test(path)
      ) {
        $('.main-container, .main-right, .main-right-wrapper').addClass('is-article')
      } else {
        $('.main-container, .main-right, .main-right-wrapper').removeClass('is-article')
      }
    }

    const gray = "none"
    const setGrayStyle = () => {
      if (gray === 'none') {
        return
      } else if (gray === 'index') {
        location.pathname === '/' ? $('#gray').show() : $('#gray').hide()
      } else if (gray === 'all') {
        $('#gray').show()
      }
    }
    setGrayStyle()


    window.onload = function () {
      checkAndSetArticlePageLayout()
      setTimeout(() => {
        $('#load').slideUp()
        $('#container').slideToggle()
        setTimeout(() => {
          initScroll();
        }, 500)
      }, 500)
    }
    
    let status = 0
    // 对所有链接跳转事件绑定pjax容器container
    $(document).pjax('a[target!=_blank]', '#main-container', {
      container: '#main-container',
      fragment: '#main-container',
      timeout: 8000
    })

    $(document).on('pjax:start', function() {
    })
    $(document).on('pjax:complete', function() {
      status = 0
      $('.main-container').addClass('to-up').on('animationend', function() {
        $(this).removeClass('to-up')
      })
      setGrayStyle()
      checkAndSetArticlePageLayout()
    })
    $(document).on('pjax:popstate', function() {
      status = -1
      checkAndSetArticlePageLayout()
    });
  </script>
</body>
</html>